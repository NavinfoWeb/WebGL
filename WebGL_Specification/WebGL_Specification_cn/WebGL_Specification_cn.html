<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0051) -->
<html
        lang="zh-CN"
        class="translated-ltr"
>
<head>
    <meta
            http-equiv="Content-Type"
            content="text/html; charset=UTF-8"
    >

    <title>WebGL规范</title>
    <meta
            name="generator"
            content="BBEdit 9.1"
    >
    <link
            rel="stylesheet"
            type="text/css"
            href="./WebGL_Specification_cn_files/Khronos-Final.css"
    >
    <script
            src="./WebGL_Specification_cn_files/jquery-1.3.2.min.js"
            type="application/javascript"
    ></script>
    <script
            src="./WebGL_Specification_cn_files/generateTOC.js"
            type="application/javascript"
    ></script>
    <link
            type="text/css"
            rel="stylesheet"
            charset="UTF-8"
            href="./WebGL_Specification_cn_files/translateelement.css"
    >
</head>
<body onload="generateTOC(document.getElementById('toc'));">
<!--begin-logo-->
<div class="head">
    <div class="left">
        <p>
            <a href="http://webgl.org/">
                <img
                        alt="WebGL的"
                        width="240"
                        height="100"
                        src="./WebGL_Specification_cn_files/WebGL-Logo.png"
                >
            </a>
        </p>
    </div>
    <div class="right">
        <p>
            <a href="http://khronos.org/">
                <img
                        alt="Khronos的"
                        height="60"
                        src="./WebGL_Specification_cn_files/KhronosGroup-3D.png"
                        width="220"
                >
            </a>
        </p>
    </div>
</div>
<div style="clear: both;"></div>
<!--end-logo-->

<h1>WebGL规范</h1>
<h2 class="no-toc">版本1.0.3，2014年10月27日</h2>
<dl>
    <dt>这个版本：</dt>
    <dd>
        <a href="https://www.khronos.org/registry/webgl/specs/1.0.3/">
            https://www.khronos.org/registry/webgl/specs/1.0.3/
        </a>
        <br>
        <a href="webgl.idl">
            <b>WebIDL：</b> https://www.khronos.org/registry/webgl/specs/1.0.3/webgl.idl
        </a>
    </dd>
    <dt>最新版本：</dt>
    <dd>
        <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/">
            https://www.khronos.org/registry/webgl/specs/latest/1.0/
        </a>
        <br>
        <a href="https://www.khronos.org/registry/webgl/specs/latest/1.0/webgl.idl">
            <b>WebIDL：</b>https://www.khronos.org/registry/webgl/specs/latest/1.0/webgl.idl
        </a>
    </dd>
    <dt>以前的版本：</dt>
    <dd>
        <a href="https://www.khronos.org/registry/webgl/specs/1.0.2/">
            https://www.khronos.org/registry/webgl/specs/1.0.2/
        </a>
        <br>
        <a href="https://www.khronos.org/registry/webgl/specs/1.0.2/webgl.idl">
            <b>WebIDL：</b>https://www.khronos.org/registry/webgl/specs/1.0.2/webgl.idl
        </a>
    </dd>
    <dt>编辑：</dt>
    <dd>
        <a href="mailto:dino@apple.com">Dean Jackson </a>
        <a href="http://www.apple.com/">（AppleInc.）</a>
    </dd>
</dl>

<span style="font-size: x-small; font-style: oblique">版权所有©2014 Khronos Group</span>

<hr>

<h2 class="no-toc">摘要</h2>
<p>
    此规范描述了
    <a
            href="https://www.w3.org/TR/html5/scripting-1.html#the-canvas-element"
            title="HTML 5 Canvas元素"
    >
        HTML 5 <span class="prop-name">canvas</span>元素</a>
    <a href="#refsCANVAS">[CANVAS]</a>
    的附加渲染上下文和支持对象。此上下文允许使用符合OpenGL ES 2.0 API的API进行渲染。
</p>

<h2 class="no-toc">本文件的状态</h2>

<!--begin-status-->
<p>
    欢迎在（<a href="https://www.khronos.org/webgl/public-mailing-list/archives/">存档的</a>）
    WebGL邮件列表<a href="mailto:public_webgl@khronos.org">public_webgl@khronos.org</a>上公开讨论此规范
    （请参阅<a href="http://www.khronos.org/webgl/public-mailing-list/">说明</a>）。
</p>
<!--end-status-->

<h2 class="no-toc">目录</h2>
<div id="toc">
</div>

<h2 id="1">简介</h2>
<div class="note">
    <p>
        WebGL™是为网络设计的即时模式3D渲染API。它源自OpenGL® ES 2.0，并在HTML上下文中提供类似的渲染功能。WebGL被设计为HTML
        Canvas元素的渲染上下文。HTML Canvas为网页中的程序化渲染提供了目标，并允许使用不同的渲染API执行该渲染。唯一这样的接口
        是Canvas 2D渲染上下文CanvasRenderingContext2D,它被描述为Canvas规范的一部分。本文档描述了另一个这样的接口
        WebGLRenderingContext，它提供了WebGL API。
    </p>

    <p>
        WebGL API的即时模式本质上与大多数Web API不同。鉴于3D图形的许多用例，WebGL选择提供可应用于任何用例的灵活原语的方法。
        库可以在WebGL之上提供更适合特定领域的API，从而为WebGL添加便利层，可以加速和简化开发。而且，由于其OpenGL ES 2.0的传承，
        对熟悉现代桌面OpenGL或OpenGL ES 2.0开发的开发人员来说，转换到WebGL开发应该是直截了当的。
    </p>
</div>

<h3 id="1.1">约定</h3>

<p>
    本文档中描述的许多函数都包含指向OpenGL ES手册页的链接。虽然我们尽一切努力使这些页面符合OpenGL ES
    2.0规范<a href="#refsGLES20">[GLES20]</a>，
    但它们可能包含错误。在矛盾的情况下，OpenGL ES 2.0规范是最终权威。
</p>

<p>
    本文档的其余部分旨在结合OpenGL ES 2.0规范（撰写本文时的2.0.25，可从<a href="http://www.khronos.org/registry/gles/">
    Khronos OpenGL ES API Registry获得</a>）阅读。除非另有说明，否则每种方法的行为都由OpenGL ES 2.0
    规范定义。此规范可能与OpenGL ES 2.0不同，以确保互操作性或安全性，通常是那些OpenGL ES 2.0留下实现定义的区域。
    这些差异总结在<a href="#webgl_gl_differences">
    WebGL和OpenGL ES 2.0之间</a>的<a href="#webgl_gl_differences">
    差异</a>部分。
</p>

<!-- ======================================================================================================= -->

<h2 id="2">上下文创建和绘图缓冲区介绍</h2>

<p>
    在使用WebGL API之前，作者必须获取给定的HTMLCanvasElement <a href="#refsCANVAS">[CANVAS]</a>
    的<code>WebGLRenderingContext</code>对象，如下所述。此对象用于管理OpenGL状态并渲染到绘图缓冲区，该缓冲区必须在创建上下文时创建。
</p>

<!-- ======================================================================================================= -->

<h3 id="2.1">上下文创建</h3>

<p>
    每个<code>WebGLRenderingContext</code>都有一个关联的<b><a name="context-canvas">canvas</a></b>属性，
    在创建时设置，它是一个<em>canvas</em><a href="#refsCANVAS">[CANVAS]</a>对象。
</p>
<p>
    每个<code>WebGLRenderingContext</code>都具有在创建时设置的
    <b><a name="context-creation-parameters">上下文创建参数</a></b>,这些参数在
    <a href="#WEBGLCONTEXTATTRIBUTES">
        <code>WebGLContextAttributes</code>
    </a>对象中。
</p>
<p>
    每个<code>WebGLRenderingContext</code>都有<b><a name="actual-context-parameters">实际的上下文参数</a></b>，
    每次在创建绘图缓冲区时设置,这些参数也在<a href="#WEBGLCONTEXTATTRIBUTES"><code>WebGLContextAttributes</code></a>
    对象中。
</p>
<p>
    每个<code>WebGLRenderingContext</code>都有一个<b><a name="webgl-context-lost-flag">webgl上下文丢失标志</a></b>，最初未设置。
</p>
<p>
    当<code>canvas</code>元素的<code>getContext()</code>方法是用<code>webgl</code>
    <a href="#refsCANVASCONTEXTS">[CANVASCONTEXTS]</a>
    为<em>contextId</em>参数返回一个新对象时，用户代理必须执行以下步骤：
</p>
<ol class="nestedlist">
    <li> 创建一个新<code>WebGLRenderingContext</code>对象,<em>context</em>。</li>
    <li> 让<em>context</em>的<a href="#context-canvas">canvas</a>
        成为与该<code>getContext()</code>方法相关联的canvas。
    </li>
    <li> 创建一个新<code>WebGLContextAttributes</code>对象,<em>contextAttributes</em>。</li>
    <li> 如果<code>getContext()</code>被调用的时候具有第二个参数<em>options</em>
        ，则将<em>options</em>中指定属性设置到<em>contextAttributes</em>的属性中。
    </li>
    <li> 使用<em>contextAttributes</em>中指定的设置
        <a href="#create-a-drawing-buffer">创建<em>绘图缓冲区</em></a>，
        并将<em>绘图缓冲区</em>与<em>context</em>相关联。
    </li>
    <li> 如果绘图缓冲区创建失败，请执行以下步骤：
        <ol class="nestedlist">
            <li>
                在<em>canvas</em>上<a href="#fire-a-webgl-context-creation-error">触发WebGL上下文创建错误</a>。
            </li>
            <li> 返回null并终止这些步骤。</li>
        </ol>
    </li>
    <li> 根据新创建的绘图缓冲区的属性设置<em>contextAttributes</em>的属性。</li>
    <li> 将<em>context</em>的
        <a href="#context-creation-parameters">上下文创建参数设置</a>为<em>contextAttributes</em>。
    </li>
    <li> 返回<em>context</em>。</li>
</ol>
<p></p>
<div class="note">
    <p>
        canvas上下文类型“experimental-webgl”历来用于访问尚未完成的WebGL实现。
    </p>
</div>
<p>
    如果用户代理同时支持canvas<code>webgl</code>和<code>experimental-webgl</code>canvas上下文类型，
    则应将它们视为别名。例如，如果调用<code>getContext('webgl')</code>成功创建WebGLRenderingContext，
    则后续调用<code>getContext('experimental-webgl')</code>将返回相同的上下文对象。
</p>

<!-- ======================================================================================================= -->

<h3 id="2.2">
    <a name="THE_DRAWING_BUFFER">绘图缓冲区</a>
</h3>

<p>
    应在创建WebGLRenderingContext对象时定义渲染API调用的绘图缓冲区。
    以下描述定义了如何<b><a name="create-a-drawing-buffer">创建绘图缓冲区</a></b>。
</p>
<p>
    下表显示构成绘图缓冲区的所有缓冲区，以及它们的最小尺寸以及它们是否默认定义。
    此绘图缓冲区的大小应由HTMLCanvasElement 的<code>width</code>和<code>height</code>属性确定。
    下表还显示了首次创建时，更改大小时或当上下文创建属性<code>preserveDrawingBuffer</code>
    为<code>false</code>时在渲染后应该要被清除的值。
</p>
<table class="foo">
    <tbody>
    <tr>
        <th>缓冲区</th>
        <th>清除值</th>
        <th>最小尺寸</th>
        <th>默认定义？</th>
    </tr>
    <tr>
        <td>颜色</td>
        <td>（0,0,0,0）</td>
        <td>每个通道8位</td>
        <td>是</td>
    </tr>
    <tr>
        <td>深度</td>
        <td>1.0</td>
        <td>16位整数</td>
        <td>是</td>
    </tr>
    <tr>
        <td>模版</td>
        <td>0</td>
        <td>8位</td>
        <td>没有</td>
    </tr>
    </tbody>
</table>
<br>
<p>
    如果所请求的宽度或高度不能被满足，在首次创建时绘制缓冲区或当<code>HTMLCanvasElement</code>的
    <code>width</code>和<code>height</code>的属性被改变时，应产生具有较小尺寸的绘图缓冲区。实际使用
    的尺寸取决于实现，并且无法保证将创建具有相同宽高比的缓冲区。可以从<code>drawingBufferWidth</code>和
    <code>drawingBufferHeight</code>属性中获取实际的绘图缓冲区大小。
</p>
<p>
    WebGL实现不得在高清显示器上对绘图缓冲区的大小执行任何自动缩放。上下文的<code>drawingBufferWidth</code>
    和<code>drawingBufferHeight</code>必须尽可能地匹配canvas的<code>width</code>
    和<code>height</code>属性，模数依赖于实现的约束。
</p>
<div class="note">
    <p>
        上面的约束不会改变canvas元素在网页上消耗的空间量，即使在高清显示器上也是如此。
        canvas的<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#attr-canvas-width">内在尺寸</a>
        <a href="#refsCANVAS">[CANVAS]</a>等于其坐标空间的大小，数字以CSS像素解释，CSS像素与
        <a href="http://www.w3.org/TR/CSS21/syndata.html#length-units">分辨率无关</a>
        <a href="#refsCSS">[CSS]</a>。
    </p>
    <p>
        WebGL应用程序可以通过检查属性，如<code>window.devicePixelRatio</code>,然后通过比例因子缩放canvas的<code>width</code>
        和<code>height</code>，并将其CSS宽度和高度设置为原始宽度和高度，达到在高清显示器上绘制缓冲区像素和屏幕上像素之间的比例为1：1。
        应用程序可以通过放大canvas的<code>width</code>和<code>height</code>属性来模拟在更高分辨率的显示器上运行的效果。
    </p>
</div>
<p>
    可选的<a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a>
    对象可用于更改是否定义缓冲区。它还可用于定义颜色缓冲区是否包含alpha通道。如果已定义，则HTML合成器将使用Alpha通道将颜色缓冲区与
    页面的其余部分组合在一起。WebGLContextAttributes对象仅在第一次调用<code>getContext</code>时使用。在创建绘图缓冲区后，没有
    提供更改绘图缓冲区属性的工具。
</p>
<p>
    至于<code>depth</code>，<code>stencil</code>和<code>antialias</code>属性，当设置为true，则请求，而不是要求。
    WebGL实现应该尽最大努力来兑现它们。但是，当这些属性中的任何一个设置为false时，WebGL实现不得提供相关的功能。
    WebGL实现或图形硬件不支持的属性组合不应导致创建WebGLRenderingContext失败。
    <a href="#actual-context-parameters">实际的上下文参数</a>被设置为
    创建绘图缓冲区的属性。<code>alpha</code>，<code>premultipliedAlpha</code>和<code>preserveDrawingBuffer</code>
    属性必须通过WebGL的实现来遵守。
</p>
<p>
    WebGL在合成操作之前立即将其绘图缓冲区提供给HTML页面合成器，但前提是自上一次合成操作后至少发生以下一种情况：
</p>
<ul>
    <li>上下文创建</li>
    <li>canvas调整大小</li>
    <li>
        <code>clear</code>,<code>drawArrays</code>或<code>drawElements</code>在绘图缓冲区是当前绑定的帧缓冲区时被调用
    </li>
</ul>
<p></p>
<p>
    在绘图缓冲区用于合成之前，实现应确保所有渲染操作都已刷新到绘图缓冲区。默认情况下，在合成后，绘图缓冲区的内容应清除为其默认值，如上表所示。
</p>
<p>
    可以通过设置<a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a>
    对象的<code>preserveDrawingBuffer</code>属性来更改此默认行为。如果此标志为true，则应保留绘图缓冲区的内容，直到作者清除或覆盖它们为止。
    如果此标志为false，则在渲染函数返回后尝试使用此上下文作为源图像执行操作可能会导致未定义的行为。这包括调用<code>readPixels</code>和
    <code>toDataURL</code>，或使用此上下文作为另一个上下文调用<code>texImage2D</code>和<code>drawImage</code>的源图像。
</p>
<div class="note">
    <p>
        虽然有时需要保留绘图缓冲区，但它可能会在某些平台上造成严重的性能损失。
        只要有可能，此标志应保持为false并使用其他技术。诸如同步绘图缓冲区访问
        （例如，在渲染到绘图缓冲区的相同函数中调用<code>readPixels</code>或<code>toDataURL</code>）之类的技术可用于获取绘图缓冲区的内容。
        如果作者需要通过一系列调用渲染到相同的绘图缓冲区，则可以使用
        <a href="#WEBGL_FRAMEBUFFER">Framebuffer对象</a>。
    </p>
    <p>
        只要能够保证作者无法访问来自另一个进程的缓冲区内容，实现可以优化掉对绘图缓冲区的隐式清除操作请求。
        例如，如果作者执行明确的清除，则不需要隐式清除。
    </p>
</div>

<!-- ======================================================================================================= -->

<h3 id="2.3">
    <a name="WEBGL_VIEWPORT">WebGL视口</a>
</h3>

<p>
    OpenGL管理矩形视口作为其状态的一部分，该视口定义渲染结果在绘图缓冲区中的位置。
    在创建WebGL上下文<em>context</em>时，视口被初始化为一个矩形，其原点为（0,0），
    宽度和高度等于（context.drawingBufferWidth，context.drawingBufferHeight）。
</p>
<p>
    WebGL实现<em>不应</em>影响OpenGL视口的状态,在响应canvas元素的大小调整的时候。
</p>
<div class="example">
    请注意，如果WebGL程序不包含设置视口的逻辑，因此无法正确处理调整canvas大小的情况。
    以下ECMAScript示例说明了WebGL程序如何以编程方式调整canvas大小。
    <pre>
        var canvas = document.getElementById('canvas1');
        var gl = canvas.getContext('webgl');
        canvas.width = newWidth;
        canvas.height = newHeight;
        gl.viewport(0,0，gl.drawingBufferWidth，gl.drawingBufferHeight);
    </pre>
</div>
<p>
    <em>基本原理</em>：自动设置视口会干扰手动设置的应用程序。应用程序应使用<code>onresize</code>处理程序来响应canvas大小的变化并反过来设置OpenGL视口。
</p>

<!-- ======================================================================================================= -->

<h3 id="2.4">
    <a name="PREMULTIPLIED_ALPHA">预乘Alpha，Canvas APIs和texImage2D</a></h3>
<p>
    OpenGL API允许应用程序修改渲染过程中使用的混合模式，因此可以控制绘制缓冲区中alpha值的解释方式;
    请参阅<a href="#WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a>
    部分中的<code>premultipliedAlpha</code>参数。
</p>
<p>
    HTML Canvas API <code>toDataURL</code>和<code>drawImage</code>必须遵守<code>premultipliedAlpha</code>上下文创建参数。
    当<code>toDataURL</code>针对已经渲染WebGL内容的Canvas调用时，如果请求的图像格式未指定premultiplied Alpha并且WebGL上下文将
    <code>premultipliedAlpha</code>参数设置为true，则必须对像素值进行反乘法运算;即颜色通道除以alpha通道。<b>请注意</b>，
    此操作是有损的。
</p>
<p>
    将渲染过WebGL内容的Canvas传递给<code>CanvasRenderingContext2D</code>的<code>drawImage</code>方法可能需要也可能不需要在
    绘制操作期间修改渲染的WebGL渲染内容，具体取决于<code>CanvasRenderingContext2D</code>实现的预乘需求。
</p>
<p>
    当将渲染过WebGL内容的Canvas传递给<code>texImage2D</code>API时，则根据canvas的<code>premultipliedAlpha</code>上下文创建参数
    的设置和目标WebGL上下文的像素存储参数<code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>，可能需要将像素数据更改为预乘形式或从预乘形式更改。
</p>

<!-- ======================================================================================================= -->

<h2 id="3">
    WebGL资源
</h2>
<p>
    OpenGL管理几种类型的资源作为其状态的一部分。它们使用整数对象名称作为标识，并通过各种创建调用从OpenGL获得。
    相比之下，WebGL将这些资源表示为DOM对象。每个对象都是从WebGLObject接口派生的。目前支持的资源包括：
    纹理，缓冲区（即VBO），帧缓冲区，渲染缓冲区，着色器和程序。对于每种类型的WebGLObject子类,
    WebGLRenderingContext接口都有一个对应的创建方法。来自底层图形库的数据存储在这些对象中，并由它们完全管理。
    只要对象存在，就保证这些对象表示的资源存在。此外，这些DOM对象可以保证在作者持有有效引用<b>或者</b>受底层
    图形库约束的情况下一直存在。当这些条件都不存在时，用户代理可以在任何时候使用等效的删除调用（例如，deleteTexture）
    删除对象。如果作者希望控制何时释放底层资源，则可以显式地进行删除调用。
</p>

<!-- ======================================================================================================= -->

<h2 id="4">安全</h2>

<p>
</p>

<!-- ======================================================================================================= -->

<h3 id="4.1">资源限制</h3>

<p>
    纹理和顶点缓冲区对象（VBO）等WebGL资源必须始终包含初始化数据，即使它们是在没有初始用户数据值的情况下创建的。
    创建没有初始值的资源通常用于为纹理或VBO保留空间，然后使用<code>texSubImage</code>或<code>bufferSubData</code>
    调用修改它。如果未向这些调用提供初始数据，则WebGL实现必须将其内容初始化为0;必须将深度渲染缓冲区清除为默认的1.0深度。
    这可能需要创建一个与请求的VBO大小相同的归零缓冲区，以便可以正确初始化它。所有加载到纹理或VBO中的其他形式数据
    涉及ArrayBuffers或DOM对象（例如图像），都需要是已经初始化的。
</p>

<p>
    当着色器通过诸如<code>drawElements</code>或<code>drawArrays</code>之类的调用访问WebGL资源时
    ，WebGL实现必须确保着色器无法访问超出边界或未初始化的数据。有关必须由WebGL实现强制执行的限制，请参阅
    <a href="#ATTRIBS_AND_RANGE_CHECKING">启用顶点属性和范围检查</a>。
</p>

<!-- ======================================================================================================= -->

<h3 id="4.2">
    <a name="ORIGIN_RESTRICTIONS">源限制</a>
</h3>

<p>
    为了防止信息泄露，WebGL不允许以下情况上传为纹理：
</p>
<ul>
    <li>
        图像或视频元素的源与包含WebGLRenderingContext的canvas元素的Document的源不同
    </li>
    <li>
        其<i>origin-clean</i>标志设置为false的canvas元素
    </li>
</ul>
<p></p>
<p>
    如果<code>texImage2D</code>或<code>texSubImage2D</code>方法被使用正确的参数调用，但是
    <code>HTMLImageElement</code>，<code>HTMLVideoElement</code>或<code>HTMLCanvasElement</code>
    违反这些限制，一个<code>SECURITY_ERR</code>异常必须被抛出。
</p>
<div class="note">
    <p>
        与其他API（如2D canvas渲染上下文）相比，WebGL必然对跨域媒体的使用施加更强的限制，因为着色器可用于间接
        推断已上载到GPU的纹理内容。
    </p>
    <p>
        WebGL应用程序可以使用<a href="http://www.w3.org/TR/cors/">Cross-Origin Resource Sharing</a>
        <a href="#refsCORS">[CORS]</a>，和托管媒体
        的服务器的协作，利用来自其他域的图像和视频。为了使用此类媒体，应用程序需要明确请求权限，服务器需要明确
        授予权限。成功启用CORS从其他域获取图像和视频元素
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/origin-0.html#origin-0">会导致这些元素的源</a>
        被设置为包含文档<a href="#refsHTML">[HTML] </a>。
    </p>
    <div class="example">
        <p>
            以下ECMAScript示例演示了如何为来自其他域的image发出CORS请求。无需任何凭据(例如cookie)即可从服务器获取image。
        </p>
        <pre>
            var gl = ...;
            var image = new Image();

            // onload处理程序应设置为函数,使用texImage2D或texSubImage2D上传HTMLImageElement
            image.onload = ...;

            image.crossOrigin =“匿名”;

            image.src =“http://other-domain.com/image.jpg”;
        </pre>
    </div>
    <p>
        请注意，这些规则意味着使用WebGL渲染的canvas的<i>origin-clean</i>标志永远不会设置为false。
    </p>
    <p>
        有关发起图像和视频元素的CORS请求的更多信息，请参阅：
    </p>
    <ul>
        <li>
            <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#cors-settings-attribute">CORS设置属性</a>
            <a href="#refsHTML">[HTML]</a>
        </li>
        <li>
            <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content-1.html#the-img-element"><code>img</code>元素</a>
            <a href="#refsHTML">[HTML]</a>
        </li>
        <li>
            <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/the-iframe-element.html#media-elements">媒体元素</a>
            <a href="#refsHTML">[HTML]</a>
        </li>
    </ul>
    <p></p>
</div>

<!-- ======================================================================================================= -->

<h3 id="4.3">
    <a name="SUPPORTED_GLSL_CONSTRUCTS">支持的GLSL结构</a>
</h3>

<p>
    WebGL实现必须只接受符合OpenGL ES着色语言版本1.00
    <a href="#refsGLES20GLSL">[GLES20GLSL]</a>的
    着色器，并且这些着色器不超过附录A第4节和第5节中规定的最小功能。特别是：
</p>
<ul>
    <li>
        不得允许加载引用其他版本(例如桌面OpenGL版本)的GLSL中可用的状态变量或函数的着色器。
    </li>
    <li><code>for</code>循环必须符合附录A中的结构约束。</li>
    <li>
        <code>while</code>和<code>do-while</code>循环是不允许的，因为它们是在附录A可选
    </li>
    <li>
        附录A规定了某些形式的数组索引; 例如，在片段着色器中，索引仅强制使用<i>常量索引表达式</i>
        （有关此术语的定义，请参阅<a href="#refsGLES20GLSL">[GLES20GLSL]</a>）。
        在WebGL API中，仅支持附录A中规定的索引形式。
    </li>
</ul>
<p></p>
<p>
    除了上述规范中的保留标识符之外，以“webgl_”和“_webgl_”开头的标识符保留供WebGL使用。
    必须不允许加载声明以这些前缀开头的函数，变量，结构名称或结构字段的着色器。
</p>

<!-- ======================================================================================================= -->

<h3 id="4.4">防止拒绝服务</h3>

<div class="note">
    <p>
        不管是有意或无意,创建着色器和几何体的组合可能需要花费很长的时间来渲染。此问题类似于长时间运行的脚本，
        用户代理已经有了安全保护。但是，长时间运行的绘制调用会导致整个窗口系统（而不仅仅是用户代理）失去交互性。
    </p>

    <p>
        在一般情况下，不可能对传入着色器的结构施加限制以防止此问题。实验表明，即使非常严格的结构限制也不足以
        防止长渲染时间，并且这种限制会阻止着色器作者实现常见算法。
    </p>

    <p>
        用户代理应实施安全措施，以防止过长的渲染时间和相关的交互性丢失。建议的保障措施包括：
    </p>

    <ul>
        <li> 将具有大量元素的绘制调用拆分为较小的绘制调用。</li>
        <li>
            如果超过某个超时，则定时单个绘制调用并禁止从页面进一步渲染。
        </li>
        <li>
            使用用户级别，图形API级别或操作系统级别提供的任何监视工具来限制绘制调用的持续时间。
        </li>
        <li>
            将用户代理的图形渲染分离为可以终止和重新启动而不会丢失应用程序状态的不同操作系统进程。
        </li>
    </ul>

    <p>
        OS和图形API层的支持基础架构预计会随着时间的推移而改进，这就是为什么没有指定这些安全措施的确切性质的原因。
    </p>
</div>
<!-- ======================================================================================================= -->

<h3 id="4.5">
    <a name="OUT_OF_RANGE_ARRAY_ACCESSES">数组访问越界</a>
</h3>

<p>
    不允许着色器读取或写入位于数组边界之外的数组元素。这包括任何数组类型，以及矢量或矩阵类型，
    例如<code>vec3</code>或<code>mat4</code>使用数组下标语法访问时。如果在编译期间检测到，则此类
    访问必须生成错误并阻止着色器编译。否则，在运行时，它们应返回零或同一数组的任何有效索引处的值。
</p>
<div class="note">
    <p>
        有关简化着色器中数组索引操作的静态分析的限制的详细信息，
        请参阅<a href="#SUPPORTED_GLSL_CONSTRUCTS">支持的GLSL结构</a>。
    </p>
</div>
<!-- ======================================================================================================= -->

<h2 id="5">DOM接口</h2>

<p>
    本节描述添加到DOM的接口和功能，以支持对上述功能的运行时访问。
</p>

<!-- ======================================================================================================= -->

<h3 id="5.1">类型</h3>

<p>
    以下部分中的所有接口都使用以下类型。
</p>
<pre class="idl">
    typedef unsigned long GLenum;
    typedef boolean GLboolean;
    typedef unsigned long GLbitfield;
    typedef byte GLbyte;
    / *'byte'应该是带符号的8位类型。* /
    typedef short GLshort;
    typedef long GLint;
    typedef long GLsizei;
    typedef long long GLintptr;
    typedef long long GLsizeiptr;
    //理想情况下，下面的typedef将使用“unsigned byte”，但当前在Web IDL中不存在。
    typedef octet GLubyte; / *'octet'应该是无符号的8位类型。* /
    typedef unsigned short GLushort;
    typedef unsigned long GLuint;
    typedef unrestricted float GLfloat;
    typedef unrestricted float GLclampf;
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.2">
    <a name="WEBGLCONTEXTATTRIBUTES">WebGLContextAttributes</a>
</h3>
<p>
    该<code>WebGLContextAttributes</code>词典包含绘图接口属性,被作为第二个参数传递给<code>getContext</code>方法。
</p>
<pre class="idl">
    dictionary<dfn id="WebGLContextAttributes">WebGLContextAttributes</dfn> {
        GLboolean alpha = true;
        GLboolean depth = true;
        GLboolean stencil = false;
        GLboolean antialias = true;
        GLboolean premultipliedAlpha = true;
        GLboolean preserveDrawingBuffer = false;
        GLboolean preferLowPowerToHighPerformance = false;
        GLboolean failIfMajorPerformanceCaveat = false;
    };
</pre>

<h4 id="5.2.1">上下文创建参数</h4>

<p>
    以下列表描述了WebGLContextAttributes对象中的每个属性及其用法。
    每个属性的默认值如上所示。如果没有传递第二个参数给<code>getContext</code>方法，或者传递的用户对象没有给定
    名称的属性，则使用默认值。
</p>
<dl>
    <dt><span class="prop-value">alpha</span></dt>
    <dd>
        如果值为true，则绘图缓冲区具有Alpha通道，用于执行OpenGL目标alpha操作以及与页面合成。如果值为false，
        则没有可用的alpha缓冲区。
    </dd>
    <dt><span class="prop-value">depth</span>
    </dt>
    <dd>
        如果该值为true，则绘图缓冲区具有至少16位的深度缓冲区。如果值为false，则没有可用的深度缓冲区。
    </dd>
    <dt><span class="prop-value">stencil</span>
    </dt>
    <dd>
        如果该值为true，则绘图缓冲区具有至少8位的模板缓冲区。如果值为false，则没有可用的模板缓冲区。
    </dd>
    <dt>
        <span class="prop-value">antialias</span>
    </dt>
    <dd>
        如果值为true且实现支持抗锯齿，则绘图缓冲区将使用其选择的技术（多重采样/超级采样）和质量执行抗锯齿。
        如果值为false或实现不支持抗锯齿，则不执行抗锯齿。
    </dd>
    <dt><span class="prop-value">premultipliedAlpha</span></dt>
    <dd>
        如果值为true，则页面合成器将假定绘图缓冲区包含具有预乘alpha的颜色。如果值为false，
        则页面合成器将假定绘图缓冲区中的颜色是未经过预乘的。如果<strong>alpha</strong>标志为false，则忽略此标志。
        有关标志效果的更多信息，请参见<a href="#PREMULTIPLIED_ALPHA"><code>premultipliedAlpha</code></a>。
    </dd>
    <dt><span class="prop-value">preserveDrawingBuffer</span></dt>
    <dd>
        如果为false，则一旦绘图缓冲区如<a href="#THE_DRAWING_BUFFER">绘图缓冲区</a>部分
        所述呈现，则绘图缓冲区的内容将清除为其默认值。绘图缓冲区的所有元素（颜色，深度和模板）都被清除。
        如果值为true，则不会清除缓冲区并保留其值，直到作者清除或覆盖。
        <blockquote>
            <em>
                在某些硬件上，设置<code>preserveDrawingBuffer</code>标志为true会对性能产生重大影响。
            </em>
        </blockquote>
    </dd>
    <dt><span class="prop-value">preferLowPowerToHighPerformance</span>
    </dt>
    <dd>
        提供实现提示，建议尽可能创建一个优化功耗而不是性能的上下文。
        例如，在具有多个GPU的硬件上，可能是其中一个功能较弱但功耗较低的情况。
        实现可以选择,也可能不得不忽略该提示。
    </dd>
    <dt><span class="prop-value">failIfMajorPerformanceCaveat</span>
    </dt>
    <dd>
        如果值为true，则如果实现确定创建的WebGL上下文的性能将显着低于进行等效OpenGL调用的本机应用程序
        的性能，则上下文创建将失败。这可能由于多种原因而发生，包括：
        <ul>
            <li>如果已知用户的GPU驱动程序不稳定，则实现可能会切换到软件模拟的光栅化引擎。</li>
            <li>实现可能需要将帧缓冲区从GPU内存读回到系统内存，然后再将其与页面的其余部分合并，从而显着降低性能。</li>
        </ul>
        不需要高性能的应用程序应将此参数保留为其默认值<code>false</code>。需要高性能的应用程序可以将此参数设置
        为<code>true</code>，如果上下文创建失败，则应用程序可能更喜欢使用后备渲染路径，例如2Dcanvas上下文。
        或者，应用程序可以设置此参数为<code>false</code>以重试创建WebGL上下文，同时应了解降低保真度渲染模式以
        提高性能。
    </dd>
</dl>
<div class="example">
    这是一个ECMAScript示例，它将WebGLContextAttributes参数传递给<code>getContext</code>。它假定页面上
    存在名为“canvas1”的canvas元素。
    <pre>
        var canvas = document.getElementById('canvas1');
        var context = canvas.getContext（'webgl', { antialias：false, stencil：true });
    </pre>
</div>

<!-- ======================================================================================================= -->

<h3 id="5.3">WebGLObject</h3>

<p>
    该<code>WebGLObject</code>接口是所有GL对象的父接口。
</p>
<p>
    每个<code>WebGLObject</code>都有一个<b><a name="webgl-object-invalidated-flag">invalidated</a></b>标志，
    最初未设置。
</p>
<pre class="idl">
    interface <dfn id="WebGLObject">WebGLObject</dfn> {
    };
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.4">WebGLBuffer</h3>

<p>
    该<code>WebGLBuffer</code>接口表示OpenGL缓冲对象。类似于调用glGenBuffers
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenBuffers.xml"
    >手册页</a>）</span>来创建底层对象，绑定就类似于调用glBindBuffer
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindBuffer.xml"
    >手册页</a>）</span>，并通过类似于调用glDeleteBuffers
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteBuffers.xml"
    >手册页</a>）</span>进行销毁。
</p>
<pre class="idl">
    interface <dfn id="WebGLBuffer">WebGLBuffer</dfn>：WebGLObject {
    };
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.5">
    <a name="WEBGL_FRAMEBUFFER">WebGLFramebuffer</a>
</h3>

<p>
    该<code>WebGLFramebuffer</code>接口表示OpenGL帧缓冲对象。通过类似于调用glGenFramebuffers
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES2.0§4.4.1</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenFramebuffers.xml"
    >手册页</a>）</span>来创建底层对象，绑定就类似于调用glBindFramebuffer
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES2.0§4.4.1</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindFramebuffer.xml"
    >手册页</a>）</span>，并通过类似于调用glDeleteFramebuffers
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES2.0§4.4.1</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteFramebuffers.xml"
    >手册页</a>）</span>进行销毁。
</p>
<pre class="idl">
    interface <dfn id="WebGLFramebuffer">WebGLFramebuffer</dfn>：WebGLObject {
    };
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.6">WebGLProgram</h3>

<p>
    该<code>WebGLProgram</code>接口代表一个OpenGL程序对象。通过类似于调用glCreateProgram
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateProgram.xml"
    >手册页</a>）</span>来创建底层对象，通过类似于调用glUseProgram
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUseProgram.xml"
    >手册页</a>）</span>进行使用,通过类似于调用glDeleteProgram
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteProgram.xml"
    >手册页</a>）</span>进行销毁。
</p>
<pre class="idl">
    interface <dfn id="WebGLProgram">WebGLProgram</dfn>：WebGLObject {
    };
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.7">WebGLRenderbuffer</h3>

<p>
    该<code>WebGLRenderbuffer</code>接口表示OpenGL渲染缓冲对象。通过类似于调用glGenRenderbuffers
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenRenderbuffers.xml"
    >手册页</a>）</span>来创建底层对象，绑定就类似于调用glBindRenderbuffer
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindRenderbuffer.xml"
    >手册页</a>）</span>，并通过类似于调用glDeleteRenderbuffers
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteRenderbuffers.xml"
    >手册页</a>）</span>进行销毁。
</p>
<pre class="idl">
    interface <dfn id="WebGLRenderbuffer">WebGLRenderbuffer</dfn>：WebGLObject {
    };
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.8">WebGLShader</h3>

<p>
    <code>WebGLShader</code>接口表示OpenGL着色对象。通过类似于调用glCreateShader
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES2.0§2.10.1</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateShader.xml"
    >手册页</a>）</span>创建底层对象，通过类似于调用glAttachShader
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glAttachShader.xml"
    >手册页</a>）</span>附加到一个程序，并通过类似于调用glDeleteShader
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES2.0§2.10.1</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteShader.xml"
    >手册页</a>）</span>来销毁。
</p>
<pre class="idl">
    interface <dfn id="WebGLShader">WebGLShader</dfn>：WebGLObject {
    };
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.9">WebGLTexture</h3>

<p>
    该<code>WebGLTexture</code>接口代表一个OpenGL纹理对象。通过类似于调用glGenTextures
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES2.0§3.7.13</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenTextures.xml"
    >手册页</a>）</span>来创建底层对象，通过类似于调用glBindTexture
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES2.0§3.7.13</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindTexture.xml"
    >手册页</a>）</span>进行绑定，并通过类似于调用glDeleteTextures
    <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES2.0§3.7.13</a>，<a
            class="nonnormative"
            href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteTextures.xml"
    >手册页</a>）</span>进行销毁。
</p>
<pre class="idl">
    interface <dfn id="WebGLTexture">WebGLTexture</dfn>：WebGLObject {
    };
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.10">WebGLUniformLocation</h3>

<p>
    <code>WebGLUniformLocation</code>接口表示uniform变量在着色器程序中的位置。
</p>
<pre class="idl">
    interface <dfn id="WebGLUniformLocation">WebGLUniformLocation</dfn> {
    };
</pre>

<!-- ======================================================================================================= -->

<h3 id="5.11">WebGLActiveInfo</h3>

<p>
    <code>WebGLActiveInfo</code>接口表示从getActiveAttrib和getActiveUniform调用返回的信息。
</p>
<pre class="idl">
    interface <dfn id="WebGLActiveInfo">WebGLActiveInfo</dfn> {
        readonly attribute GLint size;
        readonly attribute GLenum type;
        readonly attribute DOMString name;
    };
</pre>

<h4 id="5.11.1">属性</h4>

<p>
    可以使用以下属性：
</p>

<dl class="methods">
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLActiveInfo-size">
                size
            </a>
        </code>
        类型 <code>GLint</code>
    </dt>
    <dd>
        请求变量的大小。
    </dd>
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLActiveInfo-type">
                type
            </a>
        </code>
        类型 <code>GLenum</code>
    </dt>
    <dd>
        请求变量的数据类型。
    </dd>
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLActiveInfo-name">
                name
            </a>
        </code>
        类型 <code>DOMString</code>
    </dt>
    <dd>
        请求的变量名称。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h3 id="5.12">WebGLShaderPrecisionFormat</h3>

<p>
    <code>WebGLShaderPrecisionFormat</code>接口表示从getShaderPrecisionFormat调用返回的信息。
</p>
<pre class="idl">
    interface <dfn id="WebGLShaderPrecisionFormat">WebGLShaderPrecisionFormat</dfn> {
        readonly属性GLint rangeMin;
        readonly属性GLint rangeMax;
        readonly属性GLint精度;
    };
</pre>

<h4 id="5.12.1">属性</h4>

<p>
    可以使用以下属性：
</p>

<dl class="methods">
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLShaderPrecisionFormat-rangeMin">
                rangeMin
            </a>
        </code>
        类型 <code>GLint</code>
    </dt>
    <dd>
        可以表示的最小值的绝对值以2为底的对数。
    </dd>
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLShaderPrecisionFormat-rangeMax">
                rangeMax
            </a>
        </code>
        类型 <code>GLint</code>
    </dt>
    <dd>
        可以表示的最大值的绝对值以2为底的对数。
    </dd>
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLShaderPrecisionFormat-precision">
                precision
            </a>
        </code>
        类型 <code>GLint</code>
    </dt>
    <dd>
        可以表示的精度位数。对于整数格式，此值始终为0。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h3 id="5.13">
    <a name="ARRAYBUFFER">ArrayBuffer</a>和
    <a name="TYPEDARRAY">Typed Arrays</a>
</h3>

<p>
    顶点，索引，纹理和其他数据使用<a href="https://www.khronos.org/registry/typedarray/specs/latest/#ARRAYBUFFER">ArrayBuffer</a>
    和在<a href="https://www.khronos.org/registry/typedarray/specs/latest/">类型数组规范</a>
    <a href="#refsTYPEDARRAYS">[TYPEDARRAYS]</a>中定义的
    <a href="https://www.khronos.org/registry/typedarray/specs/latest/#TYPEDARRAYS">views</a>
    传输到WebGL实现中。
</p>
<p>
    类型数组支持创建交错的异构顶点数据；将不同的数据块上传到大的顶点缓冲区对象中；
    以及OpenGL程序所需的大多数其他用例。
</p>

<div class="example">
    这是一个ECMAScript示例，显示使用不同类型的类型化数组访问相同的ArrayBuffer。
    在这种情况下，缓冲区包含一个浮点顶点位置（x，y，z），后跟一个颜色为4个无符号字节（r，g，b，a）。
    <pre>
        var numVertices = 100;
        // 例子

        //计算缓冲区所需的大小，以字节和浮点数表示
        var vertexSize = 3 * Float32Array.BYTES_PER_ELEMENT +
        4 * Uint8Array.BYTES_PER_ELEMENT;
        var vertexSizeInFloats = vertexSize / Float32Array.BYTES_PER_ELEMENT;

        //分配缓冲区
        var buf = new ArrayBuffer（numVertices * vertexSize）;

        //将此缓冲区映射到Float32Array以访问位置
        var positionArray = new Float32Array（buf）;

        //将相同的缓冲区映射到Uint8Array以访问颜色
        var colorArray = new Uint8Array（buf）;

        //设置缓冲区中顶点和颜色的初始偏移量
        var positionIdx = 0;
        var colorIdx = 3 * Float32Array.BYTES_PER_ELEMENT;

        //初始化缓冲区
        for（var i = 0; i < numVertices; i ++）{
            positionArray [positionIdx] = ...;
            positionArray [positionIdx + 1] = ...;
            positionArray [positionIdx + 2] = ...;
            colorArray [colorIdx] = ...;
            colorArray [colorIdx + 1] = ...;
            colorArray [colorIdx + 2] = ...;
            colorArray [colorIdx + 3] = ...;
            positionIdx + = vertexSizeInFloats;
            colorIdx + = vertexSize;
        }
    </pre>
</div>

<!-- ======================================================================================================= -->

<h3 id="5.14">
    <a name="WEBGLRENDERINGCONTEXT">WebGL上下文</a>
</h3>

<p>
    <code>WebGLRenderingContext</code>对象代表一组API,允许使用OpenGL
    ES 2.0风格的代码渲染内容到canvas元素。
</p>
<p>
    在执行<code>WebGLRenderingContext</code>接口的任何方法实现
    或<code>getExtension</code>方法返回的接口的任何方法之前，必须执行以下步骤：
</p>
<ol class="nestedlist">
    <li>
        如果<code>[WebGLHandlesContextLoss]</code>扩展属性出现在被调用方法上，请执行被调用方法的实现，
        返回其结果并终止这些步骤。
    </li>
    <li>
        使<em>默认返回值</em>为false。
    </li>
    <li>
        如果设置了
        <a href="#webgl-context-lost-flag">
        webgl上下文丢失标志，</a>
        则<em>默认返回值</em>为true。
    </li>

    <li>
        如果方法的任何参数是一个设置了
        <a href="#webgl-object-invalidated-flag">
            无效标志</a>的<code>WebGLObject</code>对象，则生成<code>INVALID_OPERATION</code>错误并使
        <em>默认返回值</em>为true。
    </li>

    <li>
        如果<em>默认返回值</em>为true，请执行以下步骤：
        <ol class="nestedlist">
            <li>
                如果被调用方法的返回类型是<code>any</code>任何可空类型，则返回null。
            </li>

            <li>
                终止此算法而不调用方法实现。
            </li>
        </ol>
    </li>
    <li>
        否则，执行被调用方法的实现并返回其结果。
    </li>
</ol>
<p></p>
<p>
    有关详细信息，请参阅
    <a href="#CONTEXT_LOST">上下文丢失事件</a>。
</p>
<pre class="idl">
    [NoInterfaceObject]
    interface <dfn id="WebGLRenderingContextBase">WebGLRenderingContextBase</dfn>
    {

        /* ClearBufferMask */
        const GLenum DEPTH_BUFFER_BIT               = 0x00000100;
        const GLenum STENCIL_BUFFER_BIT             = 0x00000400;
        const GLenum COLOR_BUFFER_BIT               = 0x00004000;

        /* BeginMode */
        const GLenum POINTS                         = 0x0000;
        const GLenum LINES                          = 0x0001;
        const GLenum LINE_LOOP                      = 0x0002;
        const GLenum LINE_STRIP                     = 0x0003;
        const GLenum TRIANGLES                      = 0x0004;
        const GLenum TRIANGLE_STRIP                 = 0x0005;
        const GLenum TRIANGLE_FAN                   = 0x0006;

        /* AlphaFunction (not supported in ES20) */
        /*      NEVER */
        /*      LESS */
        /*      EQUAL */
        /*      LEQUAL */
        /*      GREATER */
        /*      NOTEQUAL */
        /*      GEQUAL */
        /*      ALWAYS */

        /* BlendingFactorDest */
        const GLenum ZERO                           = 0;
        const GLenum ONE                            = 1;
        const GLenum SRC_COLOR                      = 0x0300;
        const GLenum ONE_MINUS_SRC_COLOR            = 0x0301;
        const GLenum SRC_ALPHA                      = 0x0302;
        const GLenum ONE_MINUS_SRC_ALPHA            = 0x0303;
        const GLenum DST_ALPHA                      = 0x0304;
        const GLenum ONE_MINUS_DST_ALPHA            = 0x0305;

        /* BlendingFactorSrc */
        /*      ZERO */
        /*      ONE */
        const GLenum DST_COLOR                      = 0x0306;
        const GLenum ONE_MINUS_DST_COLOR            = 0x0307;
        const GLenum SRC_ALPHA_SATURATE             = 0x0308;
        /*      SRC_ALPHA */
        /*      ONE_MINUS_SRC_ALPHA */
        /*      DST_ALPHA */
        /*      ONE_MINUS_DST_ALPHA */

        /* BlendEquationSeparate */
        const GLenum FUNC_ADD                       = 0x8006;
        const GLenum BLEND_EQUATION                 = 0x8009;
        const GLenum BLEND_EQUATION_RGB             = 0x8009;   /* same as BLEND_EQUATION */
        const GLenum BLEND_EQUATION_ALPHA           = 0x883D;

        /* BlendSubtract */
        const GLenum FUNC_SUBTRACT                  = 0x800A;
        const GLenum FUNC_REVERSE_SUBTRACT          = 0x800B;

        /* Separate Blend Functions */
        const GLenum BLEND_DST_RGB                  = 0x80C8;
        const GLenum BLEND_SRC_RGB                  = 0x80C9;
        const GLenum BLEND_DST_ALPHA                = 0x80CA;
        const GLenum BLEND_SRC_ALPHA                = 0x80CB;
        const GLenum CONSTANT_COLOR                 = 0x8001;
        const GLenum ONE_MINUS_CONSTANT_COLOR       = 0x8002;
        const GLenum CONSTANT_ALPHA                 = 0x8003;
        const GLenum ONE_MINUS_CONSTANT_ALPHA       = 0x8004;
        const GLenum BLEND_COLOR                    = 0x8005;

        /* Buffer Objects */
        const GLenum ARRAY_BUFFER                   = 0x8892;
        const GLenum ELEMENT_ARRAY_BUFFER           = 0x8893;
        const GLenum ARRAY_BUFFER_BINDING           = 0x8894;
        const GLenum ELEMENT_ARRAY_BUFFER_BINDING   = 0x8895;

        const GLenum STREAM_DRAW                    = 0x88E0;
        const GLenum STATIC_DRAW                    = 0x88E4;
        const GLenum DYNAMIC_DRAW                   = 0x88E8;

        const GLenum BUFFER_SIZE                    = 0x8764;
        const GLenum BUFFER_USAGE                   = 0x8765;

        const GLenum CURRENT_VERTEX_ATTRIB          = 0x8626;

        /* CullFaceMode */
        const GLenum FRONT                          = 0x0404;
        const GLenum BACK                           = 0x0405;
        const GLenum FRONT_AND_BACK                 = 0x0408;

        /* DepthFunction */
        /*      NEVER */
        /*      LESS */
        /*      EQUAL */
        /*      LEQUAL */
        /*      GREATER */
        /*      NOTEQUAL */
        /*      GEQUAL */
        /*      ALWAYS */

        /* EnableCap */
        /* TEXTURE_2D */
        const GLenum CULL_FACE                      = 0x0B44;
        const GLenum BLEND                          = 0x0BE2;
        const GLenum DITHER                         = 0x0BD0;
        const GLenum STENCIL_TEST                   = 0x0B90;
        const GLenum DEPTH_TEST                     = 0x0B71;
        const GLenum SCISSOR_TEST                   = 0x0C11;
        const GLenum POLYGON_OFFSET_FILL            = 0x8037;
        const GLenum SAMPLE_ALPHA_TO_COVERAGE       = 0x809E;
        const GLenum SAMPLE_COVERAGE                = 0x80A0;

        /* ErrorCode */
        const GLenum NO_ERROR                       = 0;
        const GLenum INVALID_ENUM                   = 0x0500;
        const GLenum INVALID_VALUE                  = 0x0501;
        const GLenum INVALID_OPERATION              = 0x0502;
        const GLenum OUT_OF_MEMORY                  = 0x0505;

        /* FrontFaceDirection */
        const GLenum CW                             = 0x0900;
        const GLenum CCW                            = 0x0901;

        /* GetPName */
        const GLenum LINE_WIDTH                     = 0x0B21;
        const GLenum ALIASED_POINT_SIZE_RANGE       = 0x846D;
        const GLenum ALIASED_LINE_WIDTH_RANGE       = 0x846E;
        const GLenum CULL_FACE_MODE                 = 0x0B45;
        const GLenum FRONT_FACE                     = 0x0B46;
        const GLenum DEPTH_RANGE                    = 0x0B70;
        const GLenum DEPTH_WRITEMASK                = 0x0B72;
        const GLenum DEPTH_CLEAR_VALUE              = 0x0B73;
        const GLenum DEPTH_FUNC                     = 0x0B74;
        const GLenum STENCIL_CLEAR_VALUE            = 0x0B91;
        const GLenum STENCIL_FUNC                   = 0x0B92;
        const GLenum STENCIL_FAIL                   = 0x0B94;
        const GLenum STENCIL_PASS_DEPTH_FAIL        = 0x0B95;
        const GLenum STENCIL_PASS_DEPTH_PASS        = 0x0B96;
        const GLenum STENCIL_REF                    = 0x0B97;
        const GLenum STENCIL_VALUE_MASK             = 0x0B93;
        const GLenum STENCIL_WRITEMASK              = 0x0B98;
        const GLenum STENCIL_BACK_FUNC              = 0x8800;
        const GLenum STENCIL_BACK_FAIL              = 0x8801;
        const GLenum STENCIL_BACK_PASS_DEPTH_FAIL   = 0x8802;
        const GLenum STENCIL_BACK_PASS_DEPTH_PASS   = 0x8803;
        const GLenum STENCIL_BACK_REF               = 0x8CA3;
        const GLenum STENCIL_BACK_VALUE_MASK        = 0x8CA4;
        const GLenum STENCIL_BACK_WRITEMASK         = 0x8CA5;
        const GLenum VIEWPORT                       = 0x0BA2;
        const GLenum SCISSOR_BOX                    = 0x0C10;
        /*      SCISSOR_TEST */
        const GLenum COLOR_CLEAR_VALUE              = 0x0C22;
        const GLenum COLOR_WRITEMASK                = 0x0C23;
        const GLenum UNPACK_ALIGNMENT               = 0x0CF5;
        const GLenum PACK_ALIGNMENT                 = 0x0D05;
        const GLenum MAX_TEXTURE_SIZE               = 0x0D33;
        const GLenum MAX_VIEWPORT_DIMS              = 0x0D3A;
        const GLenum SUBPIXEL_BITS                  = 0x0D50;
        const GLenum RED_BITS                       = 0x0D52;
        const GLenum GREEN_BITS                     = 0x0D53;
        const GLenum BLUE_BITS                      = 0x0D54;
        const GLenum ALPHA_BITS                     = 0x0D55;
        const GLenum DEPTH_BITS                     = 0x0D56;
        const GLenum STENCIL_BITS                   = 0x0D57;
        const GLenum POLYGON_OFFSET_UNITS           = 0x2A00;
        /*      POLYGON_OFFSET_FILL */
        const GLenum POLYGON_OFFSET_FACTOR          = 0x8038;
        const GLenum TEXTURE_BINDING_2D             = 0x8069;
        const GLenum SAMPLE_BUFFERS                 = 0x80A8;
        const GLenum SAMPLES                        = 0x80A9;
        const GLenum SAMPLE_COVERAGE_VALUE          = 0x80AA;
        const GLenum SAMPLE_COVERAGE_INVERT         = 0x80AB;

        /* GetTextureParameter */
        /*      TEXTURE_MAG_FILTER */
        /*      TEXTURE_MIN_FILTER */
        /*      TEXTURE_WRAP_S */
        /*      TEXTURE_WRAP_T */

        const GLenum COMPRESSED_TEXTURE_FORMATS     = 0x86A3;

        /* HintMode */
        const GLenum DONT_CARE                      = 0x1100;
        const GLenum FASTEST                        = 0x1101;
        const GLenum NICEST                         = 0x1102;

        /* HintTarget */
        const GLenum GENERATE_MIPMAP_HINT            = 0x8192;

        /* DataType */
        const GLenum BYTE                           = 0x1400;
        const GLenum UNSIGNED_BYTE                  = 0x1401;
        const GLenum SHORT                          = 0x1402;
        const GLenum UNSIGNED_SHORT                 = 0x1403;
        const GLenum INT                            = 0x1404;
        const GLenum UNSIGNED_INT                   = 0x1405;
        const GLenum FLOAT                          = 0x1406;

        /* PixelFormat */
        const GLenum DEPTH_COMPONENT                = 0x1902;
        const GLenum ALPHA                          = 0x1906;
        const GLenum RGB                            = 0x1907;
        const GLenum RGBA                           = 0x1908;
        const GLenum LUMINANCE                      = 0x1909;
        const GLenum LUMINANCE_ALPHA                = 0x190A;

        /* PixelType */
        /*      UNSIGNED_BYTE */
        const GLenum UNSIGNED_SHORT_4_4_4_4         = 0x8033;
        const GLenum UNSIGNED_SHORT_5_5_5_1         = 0x8034;
        const GLenum UNSIGNED_SHORT_5_6_5           = 0x8363;

        /* Shaders */
        const GLenum FRAGMENT_SHADER                  = 0x8B30;
        const GLenum VERTEX_SHADER                    = 0x8B31;
        const GLenum MAX_VERTEX_ATTRIBS               = 0x8869;
        const GLenum MAX_VERTEX_UNIFORM_VECTORS       = 0x8DFB;
        const GLenum MAX_VARYING_VECTORS              = 0x8DFC;
        const GLenum MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
        const GLenum MAX_VERTEX_TEXTURE_IMAGE_UNITS   = 0x8B4C;
        const GLenum MAX_TEXTURE_IMAGE_UNITS          = 0x8872;
        const GLenum MAX_FRAGMENT_UNIFORM_VECTORS     = 0x8DFD;
        const GLenum SHADER_TYPE                      = 0x8B4F;
        const GLenum DELETE_STATUS                    = 0x8B80;
        const GLenum LINK_STATUS                      = 0x8B82;
        const GLenum VALIDATE_STATUS                  = 0x8B83;
        const GLenum ATTACHED_SHADERS                 = 0x8B85;
        const GLenum ACTIVE_UNIFORMS                  = 0x8B86;
        const GLenum ACTIVE_ATTRIBUTES                = 0x8B89;
        const GLenum SHADING_LANGUAGE_VERSION         = 0x8B8C;
        const GLenum CURRENT_PROGRAM                  = 0x8B8D;

        /* StencilFunction */
        const GLenum NEVER                          = 0x0200;
        const GLenum LESS                           = 0x0201;
        const GLenum EQUAL                          = 0x0202;
        const GLenum LEQUAL                         = 0x0203;
        const GLenum GREATER                        = 0x0204;
        const GLenum NOTEQUAL                       = 0x0205;
        const GLenum GEQUAL                         = 0x0206;
        const GLenum ALWAYS                         = 0x0207;

        /* StencilOp */
        /*      ZERO */
        const GLenum KEEP                           = 0x1E00;
        const GLenum REPLACE                        = 0x1E01;
        const GLenum INCR                           = 0x1E02;
        const GLenum DECR                           = 0x1E03;
        const GLenum INVERT                         = 0x150A;
        const GLenum INCR_WRAP                      = 0x8507;
        const GLenum DECR_WRAP                      = 0x8508;

        /* StringName */
        const GLenum VENDOR                         = 0x1F00;
        const GLenum RENDERER                       = 0x1F01;
        const GLenum VERSION                        = 0x1F02;

        /* TextureMagFilter */
        const GLenum NEAREST                        = 0x2600;
        const GLenum LINEAR                         = 0x2601;

        /* TextureMinFilter */
        /*      NEAREST */
        /*      LINEAR */
        const GLenum NEAREST_MIPMAP_NEAREST         = 0x2700;
        const GLenum LINEAR_MIPMAP_NEAREST          = 0x2701;
        const GLenum NEAREST_MIPMAP_LINEAR          = 0x2702;
        const GLenum LINEAR_MIPMAP_LINEAR           = 0x2703;

        /* TextureParameterName */
        const GLenum TEXTURE_MAG_FILTER             = 0x2800;
        const GLenum TEXTURE_MIN_FILTER             = 0x2801;
        const GLenum TEXTURE_WRAP_S                 = 0x2802;
        const GLenum TEXTURE_WRAP_T                 = 0x2803;

        /* TextureTarget */
        const GLenum TEXTURE_2D                     = 0x0DE1;
        const GLenum TEXTURE                        = 0x1702;

        const GLenum TEXTURE_CUBE_MAP               = 0x8513;
        const GLenum TEXTURE_BINDING_CUBE_MAP       = 0x8514;
        const GLenum TEXTURE_CUBE_MAP_POSITIVE_X    = 0x8515;
        const GLenum TEXTURE_CUBE_MAP_NEGATIVE_X    = 0x8516;
        const GLenum TEXTURE_CUBE_MAP_POSITIVE_Y    = 0x8517;
        const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Y    = 0x8518;
        const GLenum TEXTURE_CUBE_MAP_POSITIVE_Z    = 0x8519;
        const GLenum TEXTURE_CUBE_MAP_NEGATIVE_Z    = 0x851A;
        const GLenum MAX_CUBE_MAP_TEXTURE_SIZE      = 0x851C;

        /* TextureUnit */
        const GLenum TEXTURE0                       = 0x84C0;
        const GLenum TEXTURE1                       = 0x84C1;
        const GLenum TEXTURE2                       = 0x84C2;
        const GLenum TEXTURE3                       = 0x84C3;
        const GLenum TEXTURE4                       = 0x84C4;
        const GLenum TEXTURE5                       = 0x84C5;
        const GLenum TEXTURE6                       = 0x84C6;
        const GLenum TEXTURE7                       = 0x84C7;
        const GLenum TEXTURE8                       = 0x84C8;
        const GLenum TEXTURE9                       = 0x84C9;
        const GLenum TEXTURE10                      = 0x84CA;
        const GLenum TEXTURE11                      = 0x84CB;
        const GLenum TEXTURE12                      = 0x84CC;
        const GLenum TEXTURE13                      = 0x84CD;
        const GLenum TEXTURE14                      = 0x84CE;
        const GLenum TEXTURE15                      = 0x84CF;
        const GLenum TEXTURE16                      = 0x84D0;
        const GLenum TEXTURE17                      = 0x84D1;
        const GLenum TEXTURE18                      = 0x84D2;
        const GLenum TEXTURE19                      = 0x84D3;
        const GLenum TEXTURE20                      = 0x84D4;
        const GLenum TEXTURE21                      = 0x84D5;
        const GLenum TEXTURE22                      = 0x84D6;
        const GLenum TEXTURE23                      = 0x84D7;
        const GLenum TEXTURE24                      = 0x84D8;
        const GLenum TEXTURE25                      = 0x84D9;
        const GLenum TEXTURE26                      = 0x84DA;
        const GLenum TEXTURE27                      = 0x84DB;
        const GLenum TEXTURE28                      = 0x84DC;
        const GLenum TEXTURE29                      = 0x84DD;
        const GLenum TEXTURE30                      = 0x84DE;
        const GLenum TEXTURE31                      = 0x84DF;
        const GLenum ACTIVE_TEXTURE                 = 0x84E0;

        /* TextureWrapMode */
        const GLenum REPEAT                         = 0x2901;
        const GLenum CLAMP_TO_EDGE                  = 0x812F;
        const GLenum MIRRORED_REPEAT                = 0x8370;

        /* Uniform Types */
        const GLenum FLOAT_VEC2                     = 0x8B50;
        const GLenum FLOAT_VEC3                     = 0x8B51;
        const GLenum FLOAT_VEC4                     = 0x8B52;
        const GLenum INT_VEC2                       = 0x8B53;
        const GLenum INT_VEC3                       = 0x8B54;
        const GLenum INT_VEC4                       = 0x8B55;
        const GLenum BOOL                           = 0x8B56;
        const GLenum BOOL_VEC2                      = 0x8B57;
        const GLenum BOOL_VEC3                      = 0x8B58;
        const GLenum BOOL_VEC4                      = 0x8B59;
        const GLenum FLOAT_MAT2                     = 0x8B5A;
        const GLenum FLOAT_MAT3                     = 0x8B5B;
        const GLenum FLOAT_MAT4                     = 0x8B5C;
        const GLenum SAMPLER_2D                     = 0x8B5E;
        const GLenum SAMPLER_CUBE                   = 0x8B60;

        /* Vertex Arrays */
        const GLenum VERTEX_ATTRIB_ARRAY_ENABLED        = 0x8622;
        const GLenum VERTEX_ATTRIB_ARRAY_SIZE           = 0x8623;
        const GLenum VERTEX_ATTRIB_ARRAY_STRIDE         = 0x8624;
        const GLenum VERTEX_ATTRIB_ARRAY_TYPE           = 0x8625;
        const GLenum VERTEX_ATTRIB_ARRAY_NORMALIZED     = 0x886A;
        const GLenum VERTEX_ATTRIB_ARRAY_POINTER        = 0x8645;
        const GLenum VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

        /* Read Format */
        const GLenum IMPLEMENTATION_COLOR_READ_TYPE   = 0x8B9A;
        const GLenum IMPLEMENTATION_COLOR_READ_FORMAT = 0x8B9B;

        /* Shader Source */
        const GLenum COMPILE_STATUS                 = 0x8B81;

        /* Shader Precision-Specified Types */
        const GLenum LOW_FLOAT                      = 0x8DF0;
        const GLenum MEDIUM_FLOAT                   = 0x8DF1;
        const GLenum HIGH_FLOAT                     = 0x8DF2;
        const GLenum LOW_INT                        = 0x8DF3;
        const GLenum MEDIUM_INT                     = 0x8DF4;
        const GLenum HIGH_INT                       = 0x8DF5;

        /* Framebuffer Object. */
        const GLenum FRAMEBUFFER                    = 0x8D40;
        const GLenum RENDERBUFFER                   = 0x8D41;

        const GLenum RGBA4                          = 0x8056;
        const GLenum RGB5_A1                        = 0x8057;
        const GLenum RGB565                         = 0x8D62;
        const GLenum DEPTH_COMPONENT16              = 0x81A5;
        const GLenum STENCIL_INDEX                  = 0x1901;
        const GLenum STENCIL_INDEX8                 = 0x8D48;
        const GLenum DEPTH_STENCIL                  = 0x84F9;

        const GLenum RENDERBUFFER_WIDTH             = 0x8D42;
        const GLenum RENDERBUFFER_HEIGHT            = 0x8D43;
        const GLenum RENDERBUFFER_INTERNAL_FORMAT   = 0x8D44;
        const GLenum RENDERBUFFER_RED_SIZE          = 0x8D50;
        const GLenum RENDERBUFFER_GREEN_SIZE        = 0x8D51;
        const GLenum RENDERBUFFER_BLUE_SIZE         = 0x8D52;
        const GLenum RENDERBUFFER_ALPHA_SIZE        = 0x8D53;
        const GLenum RENDERBUFFER_DEPTH_SIZE        = 0x8D54;
        const GLenum RENDERBUFFER_STENCIL_SIZE      = 0x8D55;

        const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE           = 0x8CD0;
        const GLenum FRAMEBUFFER_ATTACHMENT_OBJECT_NAME           = 0x8CD1;
        const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL         = 0x8CD2;
        const GLenum FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

        const GLenum COLOR_ATTACHMENT0              = 0x8CE0;
        const GLenum DEPTH_ATTACHMENT               = 0x8D00;
        const GLenum STENCIL_ATTACHMENT             = 0x8D20;
        const GLenum DEPTH_STENCIL_ATTACHMENT       = 0x821A;

        const GLenum NONE                           = 0;

        const GLenum FRAMEBUFFER_COMPLETE                      = 0x8CD5;
        const GLenum FRAMEBUFFER_INCOMPLETE_ATTACHMENT         = 0x8CD6;
        const GLenum FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
        const GLenum FRAMEBUFFER_INCOMPLETE_DIMENSIONS         = 0x8CD9;
        const GLenum FRAMEBUFFER_UNSUPPORTED                   = 0x8CDD;

        const GLenum FRAMEBUFFER_BINDING            = 0x8CA6;
        const GLenum RENDERBUFFER_BINDING           = 0x8CA7;
        const GLenum MAX_RENDERBUFFER_SIZE          = 0x84E8;

        const GLenum INVALID_FRAMEBUFFER_OPERATION  = 0x0506;

        /* WebGL-specific enums */
        const GLenum UNPACK_FLIP_Y_WEBGL            = 0x9240;
        const GLenum UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
        const GLenum CONTEXT_LOST_WEBGL             = 0x9242;
        const GLenum UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
        const GLenum BROWSER_DEFAULT_WEBGL          = 0x9244;

        readonly attribute HTMLCanvasElement canvas;
        readonly attribute GLsizei drawingBufferWidth;
        readonly attribute GLsizei drawingBufferHeight;

        [WebGLHandlesContextLoss] WebGLContextAttributes? getContextAttributes();
        [WebGLHandlesContextLoss] boolean isContextLost();

        sequence&lt;DOMString&gt;? getSupportedExtensions();
        object? getExtension(DOMString name);

        void activeTexture(GLenum texture);
        void attachShader(WebGLProgram? program, WebGLShader? shader);
        void bindAttribLocation(WebGLProgram? program, GLuint index, DOMString name);
        void bindBuffer(GLenum target, WebGLBuffer? buffer);
        void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer);
        void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer);
        void bindTexture(GLenum target, WebGLTexture? texture);
        void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
        void blendEquation(GLenum mode);
        void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
        void blendFunc(GLenum sfactor, GLenum dfactor);
        void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB,
                               GLenum srcAlpha, GLenum dstAlpha);

        typedef (ArrayBuffer or ArrayBufferView) BufferDataSource;
        void bufferData(GLenum target, GLsizeiptr size, GLenum usage);
        void bufferData(GLenum target, BufferDataSource? data, GLenum usage);
        void bufferSubData(GLenum target, GLintptr offset, BufferDataSource? data);

        [WebGLHandlesContextLoss] GLenum checkFramebufferStatus(GLenum target);
        void clear(GLbitfield mask);
        void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
        void clearDepth(GLclampf depth);
        void clearStencil(GLint s);
        void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
        void compileShader(WebGLShader? shader);

        void compressedTexImage2D(GLenum target, GLint level, GLenum internalformat,
                                  GLsizei width, GLsizei height, GLint border,
                                  ArrayBufferView data);
        void compressedTexSubImage2D(GLenum target, GLint level,
                                     GLint xoffset, GLint yoffset,
                                     GLsizei width, GLsizei height, GLenum format,
                                     ArrayBufferView data);

        void copyTexImage2D(GLenum target, GLint level, GLenum internalformat,
                            GLint x, GLint y, GLsizei width, GLsizei height,
                            GLint border);
        void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                               GLint x, GLint y, GLsizei width, GLsizei height);

        WebGLBuffer? createBuffer();
        WebGLFramebuffer? createFramebuffer();
        WebGLProgram? createProgram();
        WebGLRenderbuffer? createRenderbuffer();
        WebGLShader? createShader(GLenum type);
        WebGLTexture? createTexture();

        void cullFace(GLenum mode);

        void deleteBuffer(WebGLBuffer? buffer);
        void deleteFramebuffer(WebGLFramebuffer? framebuffer);
        void deleteProgram(WebGLProgram? program);
        void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer);
        void deleteShader(WebGLShader? shader);
        void deleteTexture(WebGLTexture? texture);

        void depthFunc(GLenum func);
        void depthMask(GLboolean flag);
        void depthRange(GLclampf zNear, GLclampf zFar);
        void detachShader(WebGLProgram? program, WebGLShader? shader);
        void disable(GLenum cap);
        void disableVertexAttribArray(GLuint index);
        void drawArrays(GLenum mode, GLint first, GLsizei count);
        void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset);

        void enable(GLenum cap);
        void enableVertexAttribArray(GLuint index);
        void finish();
        void flush();
        void framebufferRenderbuffer(GLenum target, GLenum attachment,
                                     GLenum renderbuffertarget,
                                     WebGLRenderbuffer? renderbuffer);
        void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget,
                                  WebGLTexture? texture, GLint level);
        void frontFace(GLenum mode);

        void generateMipmap(GLenum target);

        WebGLActiveInfo? getActiveAttrib(WebGLProgram? program, GLuint index);
        WebGLActiveInfo? getActiveUniform(WebGLProgram? program, GLuint index);
        sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram? program);

        [WebGLHandlesContextLoss] GLint getAttribLocation(WebGLProgram? program, DOMString name);

        any getBufferParameter(GLenum target, GLenum pname);
        any getParameter(GLenum pname);

        [WebGLHandlesContextLoss] GLenum getError();

        any getFramebufferAttachmentParameter(GLenum target, GLenum attachment,
                                              GLenum pname);
        any getProgramParameter(WebGLProgram? program, GLenum pname);
        DOMString? getProgramInfoLog(WebGLProgram? program);
        any getRenderbufferParameter(GLenum target, GLenum pname);
        any getShaderParameter(WebGLShader? shader, GLenum pname);
        WebGLShaderPrecisionFormat? getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype);
        DOMString? getShaderInfoLog(WebGLShader? shader);

        DOMString? getShaderSource(WebGLShader? shader);

        any getTexParameter(GLenum target, GLenum pname);

        any getUniform(WebGLProgram? program, WebGLUniformLocation? location);

        WebGLUniformLocation? getUniformLocation(WebGLProgram? program, DOMString name);

        any getVertexAttrib(GLuint index, GLenum pname);

        [WebGLHandlesContextLoss] GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname);

        void hint(GLenum target, GLenum mode);
        [WebGLHandlesContextLoss] GLboolean isBuffer(WebGLBuffer? buffer);
        [WebGLHandlesContextLoss] GLboolean isEnabled(GLenum cap);
        [WebGLHandlesContextLoss] GLboolean isFramebuffer(WebGLFramebuffer? framebuffer);
        [WebGLHandlesContextLoss] GLboolean isProgram(WebGLProgram? program);
        [WebGLHandlesContextLoss] GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer);
        [WebGLHandlesContextLoss] GLboolean isShader(WebGLShader? shader);
        [WebGLHandlesContextLoss] GLboolean isTexture(WebGLTexture? texture);
        void lineWidth(GLfloat width);
        void linkProgram(WebGLProgram? program);
        void pixelStorei(GLenum pname, GLint param);
        void polygonOffset(GLfloat factor, GLfloat units);

        void readPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                        GLenum format, GLenum type, ArrayBufferView? pixels);

        void renderbufferStorage(GLenum target, GLenum internalformat,
                                 GLsizei width, GLsizei height);
        void sampleCoverage(GLclampf value, GLboolean invert);
        void scissor(GLint x, GLint y, GLsizei width, GLsizei height);

        void shaderSource(WebGLShader? shader, DOMString source);

        void stencilFunc(GLenum func, GLint ref, GLuint mask);
        void stencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
        void stencilMask(GLuint mask);
        void stencilMaskSeparate(GLenum face, GLuint mask);
        void stencilOp(GLenum fail, GLenum zfail, GLenum zpass);
        void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass);

        typedef (ImageData or
                 HTMLImageElement or
                 HTMLCanvasElement or
                 HTMLVideoElement) TexImageSource;
        void texImage2D(GLenum target, GLint level, GLenum internalformat,
                        GLsizei width, GLsizei height, GLint border, GLenum format,
                        GLenum type, ArrayBufferView? pixels);
        void texImage2D(GLenum target, GLint level, GLenum internalformat,
                        GLenum format, GLenum type, TexImageSource? source); // May throw DOMException

        void texParameterf(GLenum target, GLenum pname, GLfloat param);
        void texParameteri(GLenum target, GLenum pname, GLint param);

        void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                           GLsizei width, GLsizei height,
                           GLenum format, GLenum type, ArrayBufferView? pixels);
        void texSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
                           GLenum format, GLenum type, TexImageSource? source); // May throw DOMException

        void uniform1f(WebGLUniformLocation? location, GLfloat x);
        void uniform1fv(WebGLUniformLocation? location, Float32Array v);
        void uniform1fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
        void uniform1i(WebGLUniformLocation? location, GLint x);
        void uniform1iv(WebGLUniformLocation? location, Int32Array v);
        void uniform1iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
        void uniform2f(WebGLUniformLocation? location, GLfloat x, GLfloat y);
        void uniform2fv(WebGLUniformLocation? location, Float32Array v);
        void uniform2fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
        void uniform2i(WebGLUniformLocation? location, GLint x, GLint y);
        void uniform2iv(WebGLUniformLocation? location, Int32Array v);
        void uniform2iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
        void uniform3f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z);
        void uniform3fv(WebGLUniformLocation? location, Float32Array v);
        void uniform3fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
        void uniform3i(WebGLUniformLocation? location, GLint x, GLint y, GLint z);
        void uniform3iv(WebGLUniformLocation? location, Int32Array v);
        void uniform3iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);
        void uniform4f(WebGLUniformLocation? location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
        void uniform4fv(WebGLUniformLocation? location, Float32Array v);
        void uniform4fv(WebGLUniformLocation? location, sequence&lt;GLfloat&gt; v);
        void uniform4i(WebGLUniformLocation? location, GLint x, GLint y, GLint z, GLint w);
        void uniform4iv(WebGLUniformLocation? location, Int32Array v);
        void uniform4iv(WebGLUniformLocation? location, sequence&lt;long&gt; v);

        void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose,
                              Float32Array value);
        void uniformMatrix2fv(WebGLUniformLocation? location, GLboolean transpose,
                              sequence&lt;GLfloat&gt; value);
        void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose,
                              Float32Array value);
        void uniformMatrix3fv(WebGLUniformLocation? location, GLboolean transpose,
                              sequence&lt;GLfloat&gt; value);
        void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose,
                              Float32Array value);
        void uniformMatrix4fv(WebGLUniformLocation? location, GLboolean transpose,
                              sequence&lt;GLfloat&gt; value);

        void useProgram(WebGLProgram? program);
        void validateProgram(WebGLProgram? program);

        void vertexAttrib1f(GLuint indx, GLfloat x);
        void vertexAttrib1fv(GLuint indx, Float32Array values);
        void vertexAttrib1fv(GLuint indx, sequence&lt;GLfloat&gt; values);
        void vertexAttrib2f(GLuint indx, GLfloat x, GLfloat y);
        void vertexAttrib2fv(GLuint indx, Float32Array values);
        void vertexAttrib2fv(GLuint indx, sequence&lt;GLfloat&gt; values);
        void vertexAttrib3f(GLuint indx, GLfloat x, GLfloat y, GLfloat z);
        void vertexAttrib3fv(GLuint indx, Float32Array values);
        void vertexAttrib3fv(GLuint indx, sequence&lt;GLfloat&gt; values);
        void vertexAttrib4f(GLuint indx, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
        void vertexAttrib4fv(GLuint indx, Float32Array values);
        void vertexAttrib4fv(GLuint indx, sequence&lt;GLfloat&gt; values);
        void vertexAttribPointer(GLuint indx, GLint size, GLenum type,
                                 GLboolean normalized, GLsizei stride, GLintptr offset);

        void viewport(GLint x, GLint y, GLsizei width, GLsizei height);
    };

    interface <dfn id="WebGLRenderingContext">WebGLRenderingContext</dfn>
    {
    };
    WebGLRenderingContext implements WebGLRenderingContextBase;
</pre>

<!-- ======================================================================================================= -->

<h4 id="5.14.1">属性</h4>

<p>
    可以使用以下属性：
</p>

<dl class="methods">
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLRenderingContext-canvas">
                canvas
            </a>
        </code>
        类型 <code>HTMLCanvasElement</code>
    </dt>
    <dd>
        对创建此上下文的canvas元素的引用。
    </dd>
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLRenderingContext-drawingBufferWidth">
                drawingBufferWidth
            </a>
        </code>
        类型 <code>GLsizei</code>
    </dt>
    <dd>
        绘图缓冲区的实际宽度。当实现无法满足请求的宽度或高度的时候,可能
        与<code>HTMLCanvasElement</code>的<code>width</code>属性不同。
    </dd>
    <dt>
        <code class="attribute-name">
            <a id="DOM-WebGLRenderingContext-drawingBufferHeight">
                drawingBufferHeight
            </a>
        </code>
        类型 <code>GLsizei</code>
    </dt>
    <dd>
        绘图缓冲区的实际高度。当实现无法满足请求的宽度或高度的时候,可能
        与<code>HTMLCanvasElement</code>的<code>height</code>属性不同。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.2">获取有关上下文的信息</h4>

<dl class="methods">
    <dt class="idl-code">
        [WebGLHandlesContextLoss]WebGLContextAttributes？getContextAttributes()
    </dt>
    <dd>
        如果设置了<a href="#webgl-context-lost-flag">
        webgl上下文丢失标志</a>，则返回null。
        否则，返回<a href="#actual-context-parameters">实际上下文参数</a>的副本。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.3">设置和获取状态</h4>

<p>
    OpenGL ES 2.0维护用于渲染的状态值。除非另有说明，否则该组中的所有调用都与其OpenGL对应的行为相同。
</p>

<dl class="methods">
    <dt class="idl-code">void activeTexture(GLenum texture)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7">OpenGL ES2.0§3.7</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glActiveTexture.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void blendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES2.0§4.1.6</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendColor.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void blendEquation(GLenum mode)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES2.0§4.1.6</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendEquation.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void blendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES2.0§4.1.6</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendEquationSeparate.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void blendFunc(GLenum sfactor, GLenum dfactor)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES2.0§4.1.6</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendFunc.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        有关WebGL的限制，请参阅
        <a href="#CONSTANT_COLOR_BLEND">常量颜色混合</a>。
    </dd>
    <dt class="idl-code">void blendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.6">OpenGL ES2.0§4.1.6</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBlendFuncSeparate.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        有关WebGL的限制，请参阅
        <a href="#CONSTANT_COLOR_BLEND">常量颜色混合</a>。
    </dd>
    <dt class="idl-code">void clearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES2.0§4.2.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearColor.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void clearDepth(GLclampf depth)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES2.0§4.2.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearDepthf.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        <code>depth</code> 值被限制在0到1的范围内。
    </dd>
    <dt class="idl-code">void clearStencil(GLint s)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES2.0§4.2.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClearStencil.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES2.0§4.2.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glColorMask.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void cullFace(GLenum mode)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.1">OpenGL ES2.0§3.5.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCullFace.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void depthFunc(GLenum func)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.5">OpenGL ES2.0§4.1.5</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthFunc.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void depthMask(GLboolean flag)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES2.0§4.2.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthMask.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void depthRange(GLclampf zNear, GLclampf zFar)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.12.1">OpenGL ES2.0§2.12.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDepthRangef.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        <code>zNear</code>并且<code>zFar</code>值被限制在0到1的范围内并且
        <code>zNear</code>必须小于或等于<code>zFar</code>; 请参阅
        <a href="#VIEWPORT_DEPTH_RANGE">视口深度范围</a>。
    </dd>
    <dt class="idl-code">void disable(GLenum cap)
        <span class="gl-spec">（<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDisable.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void enable(GLenum cap)
        <span class="gl-spec">（<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glEnable.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void frontFace(GLenum mode)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.1">OpenGL ES2.0§3.5.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFrontFace.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">
        <a name="GETPARAMETER">any getParameter</a>(GLenum pname)
        <a
                class="gl-spec"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGet.xml"
        >
            （glGet OpenGL ES 2.0 手册页）
        </a>
        <a
                class="gl-spec"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetString.xml"
        >
            （glGetString OpenGL ES 2.0 手册页）
        </a>
    </dt>
    <dd>
        返回传递的pname的值。返回的类型是请求的pname的自然类型，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>PNAME
                </th>
                <th>返回类型
                </th>
            </tr>
            <tr>
                <td>ACTIVE_TEXTURE
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>ALIASED_LINE_WIDTH_RANGE
                </td>
                <td>
                    Float32Array（含2个元素）
                </td>
            </tr>
            <tr>
                <td>ALIASED_POINT_SIZE_RANGE
                </td>
                <td>
                    Float32Array（含2个元素）
                </td>
            </tr>
            <tr>
                <td>
                    ALPHA_BITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    ARRAY_BUFFER_BINDING
                </td>
                <td>
                    WebGLBuffer
                </td>
            </tr>
            <tr>
                <td>BLEND</td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>
                    BLEND_COLOR
                </td>
                <td>
                    Float32Array（有4个值）
                </td>
            </tr>
            <tr>
                <td>BLEND_DST_ALPHA
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    BLEND_DST_RGB
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    BLEND_EQUATION_ALPHA
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    BLEND_EQUATION_RGB
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>BLEND_SRC_ALPHA
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    BLEND_SRC_RGB
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    BLUE_BITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    COLOR_CLEAR_VALUE
                </td>
                <td>
                    Float32Array（有4个值）
                </td>
            </tr>
            <tr>
                <td>COLOR_WRITEMASK
                </td>
                <td>sequence &lt;GLboolean&gt;（带4个值）
                </td>
            </tr>
            <tr>
                <td>COMPRESSED_TEXTURE_FORMATS
                </td>
                <td>
                    Uint32Array
                </td>
            </tr>
            <tr>
                <td>
                    CULL_FACE
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>CULL_FACE_MODE
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>CURRENT_PROGRAM
                </td>
                <td>
                    WebGLProgram
                </td>
            </tr>
            <tr>
                <td>
                    DEPTH_BITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    DEPTH_CLEAR_VALUE
                </td>
                <td>GLfloat
                </td>
            </tr>
            <tr>
                <td>
                    DEPTH_FUNC
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>DEPTH_RANGE
                </td>
                <td>
                    Float32Array（含2个元素）
                </td>
            </tr>
            <tr>
                <td>
                    DEPTH_TEST
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>DEPTH_WRITEMASK
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>DITHER
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>ELEMENT_ARRAY_BUFFER_BINDING
                </td>
                <td>
                    WebGLBuffer
                </td>
            </tr>
            <tr>
                <td>
                    FRAMEBUFFER_BINDING
                </td>
                <td>
                    WebGLFramebuffer
                </td>
            </tr>
            <tr>
                <td>
                    FRONT_FACE
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    GENERATE_MIPMAP_HINT
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    GREEN_BITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>IMPLEMENTATION_COLOR_READ_FORMAT
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>IMPLEMENTATION_COLOR_READ_TYPE
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>LINE_WIDTH</td>
                <td>GLfloat
                </td>
            </tr>
            <tr>
                <td>MAX_COMBINED_TEXTURE_IMAGE_UNITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>MAX_CUBE_MAP_TEXTURE_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>MAX_FRAGMENT_UNIFORM_VECTORS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    MAX_RENDERBUFFER_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>MAX_TEXTURE_IMAGE_UNITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    MAX_TEXTURE_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    MAX_VARYING_VECTORS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    MAX_VERTEX_ATTRIBS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>MAX_VERTEX_TEXTURE_IMAGE_UNITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>MAX_VERTEX_UNIFORM_VECTORS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    MAX_VIEWPORT_DIMS
                </td>
                <td>
                    Int32Array（含2个元素）
                </td>
            </tr>
            <tr>
                <td>PACK_ALIGNMENT
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    POLYGON_OFFSET_FACTOR
                </td>
                <td>GLfloat
                </td>
            </tr>
            <tr>
                <td>
                    POLYGON_OFFSET_FILL
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>
                    POLYGON_OFFSET_UNITS
                </td>
                <td>GLfloat
                </td>
            </tr>
            <tr>
                <td>RED_BITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    RENDERBUFFER_BINDING
                </td>
                <td>
                    WebGLRenderbuffer
                </td>
            </tr>
            <tr>
                <td>RENDERER</td>
                <td>
                    DOMString
                </td>
            </tr>
            <tr>
                <td>SAMPLE_BUFFERS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    SAMPLE_COVERAGE_INVERT
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>
                    SAMPLE_COVERAGE_VALUE
                </td>
                <td>GLfloat
                </td>
            </tr>
            <tr>
                <td>SAMPLES</td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    SCISSOR_BOX
                </td>
                <td>
                    Int32Array（含4个元素）
                </td>
            </tr>
            <tr>
                <td>
                    SCISSOR_TEST
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>SHADING_LANGUAGE_VERSION
                </td>
                <td>
                    DOMString
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_BACK_FAIL
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_BACK_FUNC
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>STENCIL_BACK_PASS_DEPTH_FAIL
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>STENCIL_BACK_PASS_DEPTH_PASS
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_BACK_REF
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>STENCIL_BACK_VALUE_MASK
                </td>
                <td>GLuint
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_BACK_WRITEMASK
                </td>
                <td>GLuint
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_BITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    STENCIL_CLEAR_VALUE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    STENCIL_FAIL
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_FUNC
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>STENCIL_PASS_DEPTH_FAIL
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>STENCIL_PASS_DEPTH_PASS
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_REF
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    STENCIL_TEST
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_VALUE_MASK
                </td>
                <td>GLuint
                </td>
            </tr>
            <tr>
                <td>
                    STENCIL_WRITEMASK
                </td>
                <td>GLuint
                </td>
            </tr>
            <tr>
                <td>
                    SUBPIXEL_BITS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    TEXTURE_BINDING_2D
                </td>
                <td>
                    WebGLTexture
                </td>
            </tr>
            <tr>
                <td>TEXTURE_BINDING_CUBE_MAP
                </td>
                <td>
                    WebGLTexture
                </td>
            </tr>
            <tr>
                <td>
                    UNPACK_ALIGNMENT
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>UNPACK_COLORSPACE_CONVERSION_WEBGL
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    UNPACK_FLIP_Y_WEBGL
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>UNPACK_PREMULTIPLY_ALPHA_WEBGL
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>VENDOR</td>
                <td>
                    DOMString
                </td>
            </tr>
            <tr>
                <td>VERSION</td>
                <td>
                    DOMString
                </td>
            </tr>
            <tr>
                <td>VIEWPORT</td>
                <td>
                    Int32Array（含4个元素）
                </td>
            </tr>
            </tbody>
        </table>
        <br>
        <p>
            返回序列或类型化数组的所有查询每次都返回一个新对象。
        </p>
        <p>
            如果<em>pname</em>不在上表中，则生成<code>INVALID_ENUM</code>错误并返回null。
        </p>
        <p>
            以下<em>pname</em>参数返回描述当前WebGL实现的某些方面的字符串：
        </p>
        <table>
            <tbody>
            <tr>
                <td>VERSION</td>
                <td>
                    返回版本号或发行版号,格式<code>WebGL&lt;space&gt;1.0&lt;space&gt;&lt;vendor-specific
                    information&gt;</code>。
                </td>
            </tr>
            <tr>
                <td>SHADING_LANGUAGE_VERSION
                </td>
                <td>
                    返回版本号或发行版号,格式<code>WebGL&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;1.0&lt;space&gt;&lt;vendor-specific
                    information&gt;</code>。
                </td>
            </tr>
            <tr>
                <td>VENDOR</td>
                <td>
                    返回负责此WebGL实现的公司。
                    此名称在不会随着发行版变化。
                </td>
            </tr>
            <tr>
                <td>RENDERER</td>
                <td>
                    返回渲染器的名称。
                    此名称通常特定于硬件平台的特定配置。它不会随着发行版变化。
                </td>
            </tr>
            </tbody>
        </table>
        <br>
        <p>
            有关当前WebGL实现中的可用扩展的信息，请参阅
            <a href="#EXTENSION_QUERIES">扩展查询</a>。
        </p>
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLenum getError()
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.5">OpenGL ES2.0§2.5</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetError.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果设置了上下文的<a href="#webgl-context-lost-flag">
        webgl上下文丢失标志，</a>则在第一次调用此方法时返回<code class="enum">CONTEXT_LOST_WEBGL</code>。之后，
        返回<code class="enum">NO_ERROR</code>直到上下文恢复。
    </dd>
    <dt class="idl-code">void hint(GLenum target, GLenum mode)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.2">OpenGL ES2.0§5.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glHint.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isEnabled(GLenum cap)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.1">OpenGL ES2.0§6.1.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsEnabled.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果设置了上下文的<a href="#webgl-context-lost-flag">webgl上下文丢失标志</a>，则
        返回false 。
    </dd>
    <dt class="idl-code">void lineWidth(GLfloat width)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.4">OpenGL ES2.0§3.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glLineWidth.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        有关为WebGL指定的限制，请参阅
        <a href="#NAN_LINE_WIDTH">NaN线宽</a>。
    </dd>
    <dt class="idl-code">void pixelStorei(GLenum pname, GLint param)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.6.1">OpenGL ES2.0§3.6.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glPixelStorei.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        除了OpenGL ES 2.0规范中的参数之外，
        WebGL规范还接受参数<code>UNPACK_FLIP_Y_WEBGL</code>，<code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>
        和<code>UNPACK_COLORSPACE_CONVERSION_WEBGL</code>。有关这些参数的说明，请参阅
        <a href="#PIXEL_STORAGE_PARAMETERS">像素存储</a>参数。
    </dd>
    <dt class="idl-code">void
        polygonOffset（GLfloat factor，GLfloat units）
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.5.2">OpenGL ES2.0§3.5.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glPolygonOffset.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void polygonOffset(GLfloat factor, GLfloat units)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.3">OpenGL ES2.0§4.1.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glSampleCoverage.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void sampleCoverage(GLclampf value, GLboolean invert)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES2.0§4.1.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilFunc.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void stencilFunc(GLenum func, GLint ref, GLuint mask)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES2.0§4.1.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilFuncSeparate.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        有关允许参数值的WebGL特定限制的信息，请参阅<a href="#STENCIL_SEPARATE_LIMIT">
        Stencil Separate Mask和Reference Value</a>。
    </dd>
    <dt class="idl-code">void stencilMask(GLuint mask)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES2.0§4.2.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilMask.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        有关
        许的掩码值的WebGL特定限制的信息，请参阅<a href="#STENCIL_SEPARATE_LIMIT">
        Stencil Separate Mask和Reference Value</a>。
    </dd>
    <dt class="idl-code">void stencilMaskSeparate(GLenum face, GLuint mask)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.2">OpenGL ES2.0§4.2.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilMaskSeparate.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void stencilOp(GLenum fail, GLenum zfail, GLenum zpass)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES2.0§4.1.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilOp.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void stencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.4">OpenGL ES2.0§4.1.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glStencilOpSeparate.xml"
        >手册页</a>）</span>
    </dt>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.4">查看和裁剪</h4>

<p>
    绘图命令只能修改当前绑定的帧缓冲区内的像素。此外，视口和裁剪框会影响绘图。
</p>

<p>
    视口指定x和y从标准化设备坐标到窗口坐标的仿射变换。
    最初根据<a href="#WEBGL_VIEWPORT">WebGL视口</a>
    部分中的规定来确定视口的大小。裁剪盒定义了一个约束绘图的矩形。当启用裁剪测试时，只能通过绘制命令来修改位于
    裁剪框内的像素,包括<code>clear</code>操作，并且只能在视口，当前绑定的帧缓冲区和裁剪框的交集内绘制图元。
    如果未启用裁剪测试，则只能在视口和当前绑定的帧缓冲区的交集内绘制图元。
</p>

<dl class="methods">
    <dt class="idl-code">void scissor(GLint x, GLint y, GLsizei width, GLsizei height)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.1.2">OpenGL ES2.0§4.1.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glScissor.xml"
        >手册页</a>）</span>

    </dt>
    <dt class="idl-code">void viewport(GLint x, GLint y, GLsizei width, GLsizei height)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.12.1">OpenGL ES2.0§2.12.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glViewport.xml"
        >手册页</a>）</span>
    </dt>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.5">缓冲对象</h4>

<p>
    缓冲区对象（有时称为VBO）保存GLSL着色器的顶点属性数据。
</p>

<dl class="methods">
    <dt class="idl-code">void bindBuffer(GLenum target, WebGLBuffer? buffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindBuffer.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        将给定的WebGLBuffer对象绑定到给定的绑定点（目标），ARRAY_BUFFER或ELEMENT_ARRAY_BUFFER。
        如果缓冲区为null，则当前绑定到此目标的任何缓冲区都是未绑定的。给定的WebGLBuffer对象可能
        仅在其生命周期中绑定到ARRAY_BUFFER或ELEMENT_ARRAY_BUFFER目标之一。尝试将缓冲区对象绑定
        到另一个目标将生成<code>INVALID_OPERATION</code>错误，并且当前绑定将保持不变。
    </dd>
    <dt class="idl-code">void bufferData(GLenum target, GLsizeiptr size, GLenum usage)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferData.xml"
        >手册页）</a>）</span>
    </dt>
    <dd>
        为传递的目标设置当前绑定的WebGLBuffer对象的大小。缓冲区初始化为0。
    </dd>
    <dt><p class="idl-code">void bufferData(GLenum target, BufferDataSource? data, GLenum usage)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferData.xml"
        >手册页</a>）</span>
    </p>
    </dt>
    <dd>
        为传递的目标设置当前绑定的WebGLBuffer对象的大小,大小为传递的数据大小,然后将数据的内容写入缓冲区对象。
        <br><br>
        如果传递的数据为null，则<code>INVALID_VALUE</code>生成错误。
    </dd>
    <dt><p class="idl-code">void bufferSubData(GLenum target, GLintptr offset, BufferDataSource? data)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBufferSubData.xml"
        >手册页</a>）</span>
    </p>
    </dt>
    <dd>
        对于绑定到传递的目标的WebGLBuffer对象，从传递的偏移量开始写入传递的数据。
        如果数据写入将超过缓冲区对象的末尾，则生成<code>INVALID_VALUE</code>错误。
        如果<code>data</code>为null，则生成<code>INVALID_VALUE</code>错误。
    </dd>
    <dt class="idl-code">WebGLBuffer? createBuffer()
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenBuffers.xml"
        >glGenBuffers</a>）</span>
    </dt>
    <dd>
        创建一个WebGLBuffer对象并使用缓冲区对象名称对其进行初始化，就类似于调用glGenBuffers。
    </dd>
    <dt class="idl-code">void deleteBuffer(WebGLBuffer? buffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.9">OpenGL ES2.0§2.9</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteBuffers.xml"
        >glDeleteBuffers</a>）</span>
    </dt>
    <dd>
        删除传递的WebGLBuffer中包含的缓冲区对象，就类似于调用glDeleteBuffers。
        如果缓冲区已被删除，则调用无效。请注意，销毁WebGLBuffer对象时将删除缓冲区对象。
        这种方法只是让作者更好地控制缓冲对象何时被销毁。
    </dd>
    <dt class="idl-code">any getBufferParameter(GLenum target, GLenum pname)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES2.0§6.1.3</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetBufferParameteriv.xml"
        >glGetBufferParameteriv</a>）</span>
    </dt>
    <dd>
        返回传递的pname的值。返回的类型是请求的pname的自然类型，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>pname
                </th>
                <th>returned type
                </th>
            </tr>
            <tr>
                <td>BUFFER_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    BUFFER_USAGE
                </td>
                <td>GLenum
                </td>
            </tr>
            </tbody>
        </table>
        <p>
            如果<em>pname</em>不在上表中，则生成<code>INVALID_ENUM</code>错误。
        </p>
        <p>
            如果生成OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isBuffer(WebGLBuffer? buffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.6">OpenGL ES2.0§6.1.6</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsBuffer.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果传递的WebGLBuffer有效则返回true，否则返回false。
        <br><br>
        如果设置了缓冲区的
        <a href="#webgl-object-invalidated-flag">无效标志</a>，
        则返回false 。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.6">帧缓冲对象</h4>

<p>
    帧缓冲对象为绘图缓冲区提供了另一种渲染目标。它是颜色，alpha，深度和模板缓冲区的集合，
    通常用于渲染稍后将用作纹理的图像。
</p>

<dl class="methods">
    <dt class="idl-code">void bindFramebuffer(GLenum target, WebGLFramebuffer? framebuffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES2.0§4.4.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindFramebuffer.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        将给定<code class="interface">WebGLFramebuffer</code>对象
        绑定到给定的绑定点（<code class="param">target</code>），
        该绑定点必须是<code class="enum">FRAMEBUFFER</code>。
        如果<code class="param">framebuffer</code>为null，
        则绑定上下文提供的默认帧缓冲区，并尝试修改或查询
        <code class="param">target</code>的<code class="enum">FRAMEBUFFER</code>状态
        同时将生成<code class="error">INVALID_OPERATION</code>错误。
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLenum checkFramebufferStatus(GLenum target)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.5">OpenGL ES2.0§4.4.5</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCheckFramebufferStatus.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        返回<code class="enum">FRAMEBUFFER_UNSUPPORTED</code>，如果上下文的
        <a href="#webgl-context-lost-flag">
            WebGL上下文丢失标志</a>设置为true。
    </dd>
    <dt class="idl-code">WebGLFramebuffer? createFramebuffer()
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES2.0§4.4.1</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenFramebuffers.xml"
        >glGenFramebuffers</a>）</span>
    </dt>
    <dd>
        创建一个WebGLFramebuffer对象，并使用framebuffer对象名称对其进行初始化，就类似于调用glGenFramebuffers。
    </dd>
    <dt class="idl-code">void deleteFramebuffer(WebGLFramebuffer? buffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.1">OpenGL ES2.0§4.4.1</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteFramebuffers.xml"
        >glDeleteFramebuffers</a>）</span>
    </dt>
    <dd>
        删除传递的WebGLFramebuffer中包含的framebuffer对象，就像类似于调用glDeleteFramebuffers。
        如果帧缓冲已被删除，则调用无效。请注意，当销毁WebGLFramebuffer对象时，将删除framebuffer对象。
        这个方法只是让作者更好地控制帧缓冲对象的销毁时间。
    </dd>
    <dt class="idl-code">void framebufferRenderbuffer(GLenum target, GLenum attachment,
        GLenum renderbuffertarget,
        WebGLRenderbuffer? renderbuffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFramebufferRenderbuffer.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void framebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget,
        WebGLTexture? texture, GLint level)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFramebufferTexture2D.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">any getFramebufferAttachmentParameter(GLenum target, GLenum attachment,
        GLenum pname)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES2.0§6.1.3</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetFramebufferAttachmentParameteriv.xml"
        >glGetFramebufferAttachmentParameteriv</a>）</span>
    </dt>
    <dd>
        给定传递的目标和附件，返回传递的pname的值。返回的类型是请求的pname的自然类型，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>pname
                </th>
                <th>returned type
                </th>
            </tr>
            <tr>
                <td>FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
                </td>
                <td>WebGLRenderbuffer或WebGLTexture
                </td>
            </tr>
            <tr>
                <td>FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE
                </td>
                <td>GLint</td>
            </tr>
            </tbody>
        </table>
        <p>
            如果<em>pname</em>不在上表中，则生成<code>INVALID_ENUM</code>错误。
        </p>
        <p>
            如果生成OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isFramebuffer(WebGLFramebuffer? framebuffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.7">OpenGL ES2.0§6.1.7</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsFramebuffer.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果传递的WebGLFramebuffer有效则返回true，否则返回false。
        <br><br>
        如果设置了framebuffer的
        <a href="#webgl-object-invalidated-flag">
            无效标志</a>，则返回false 。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.7">渲染缓冲对象</h4>

<p>
    Renderbuffer对象用于为framebuffer对象中使用的各个缓冲区提供存储。
</p>

<dl class="methods">
    <dt class="idl-code">void bindRenderbuffer(GLenum target, WebGLRenderbuffer? renderbuffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindRenderbuffer.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        将给定<code class="interface">WebGLRenderbuffer</code>对象
        绑定到给定的绑定点（<code class="param">target</code>），该
        绑定点必须是<code class="enum">RENDERBUFFER</code>。
        如果<code class="param">renderbuffer</code>为null，则当前绑
        定到此<code class="param">target</code>的renderbuffer对象变成未绑定。
    </dd>
    <dt class="idl-code">WebGLRenderbuffer? createRenderbuffer()
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenRenderbuffers.xml"
        >glGenRenderbuffers</a>）</span>
    </dt>
    <dd>
        创建一个WebGLRenderbuffer对象，并使用renderbuffer对象名称对其进行初始化，
        就类似于调用glGenRenderbuffers。
    </dd>
    <dt class="idl-code">void deleteRenderbuffer(WebGLRenderbuffer? renderbuffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteRenderbuffers.xml"
        >glDeleteRenderbuffers</a>）</span>
    </dt>
    <dd>
        删除传递的WebGLRenderbuffer中包含的renderbuffer对象，就类似于调用glDeleteRenderbuffers。
        如果已删除渲染缓冲区，则调用无效。请注意，销毁WebGLRenderbuffer对象时将删除renderbuffer对象。
        这个方法只是让作者更好地控制渲染缓冲对象的销毁时间。
    </dd>
    <dt class="idl-code">any getRenderbufferParameter(GLenum target, GLenum pname)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES2.0§6.1.3</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetRenderbufferParameteriv.xml"
        >glGetRenderbufferParameteriv</a>）</span>
    </dt>
    <dd>
        给定传递的目标返回传递的pname的值。返回的类型是请求的pname的自然类型，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>pname
                </th>
                <th>returned type
                </th>
            </tr>
            <tr>
                <td>
                    RENDERBUFFER_WIDTH
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    RENDERBUFFER_HEIGHT
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>RENDERBUFFER_INTERNAL_FORMAT
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    RENDERBUFFER_RED_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>RENDERBUFFER_GREEN_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    RENDERBUFFER_BLUE_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>RENDERBUFFER_ALPHA_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>RENDERBUFFER_DEPTH_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>RENDERBUFFER_STENCIL_SIZE
                </td>
                <td>GLint</td>
            </tr>
            </tbody>
        </table>
        <p>
            如果<em>pname</em>不在上表中，则生成<code>INVALID_ENUM</code>错误。
        </p>
        <p>
            如果生成OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isRenderbuffer(WebGLRenderbuffer? renderbuffer)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.7">OpenGL ES2.0§6.1.7</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsRenderbuffer.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果传递的WebGLRenderbuffer有效则返回true，否则返回false。
        <br><br>
        如果设置了renderbuffer的
        <a href="#webgl-object-invalidated-flag">
            无效标志</a>,则返回false。
    </dd>
    <dt class="idl-code">void renderbufferStorage(GLenum target, GLenum internalformat,
        GLsizei width, GLsizei height)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.4.3">OpenGL ES2.0§4.4.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glRenderbufferStorage.xml"
        >手册页</a>）</span>
    </dt>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.8">纹理对象</h4>

<p>
    纹理对象为纹理操作提供存储和状态。如果没有绑定WebGLTexture（例如，将null或0传递给bindTexture）情况下，
    尝试修改或查询纹理对象将产生<code>INVALID_OPERATION</code>错误。这会在以下功能中指出。
</p>

<dl class="methods">
    <dt class="idl-code">void bindTexture(GLenum target, WebGLTexture? texture)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES2.0§3.7.13</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindTexture.xml"
        >手册页</a>）</span>
    </dt>
    <dt>
        <p class="idl-code">
            <a name="COMPRESSEDTEXIMAGE2D">void compressedTexImage2D</a>(GLenum target, GLint level, GLenum internalformat,
            GLsizei width, GLsizei height, GLint border, ArrayBufferView pixels)
            <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.3">OpenGL ES2.0§3.7.3</a>，<a
                    class="nonnormative"
                    href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompressedTexImage2D.xml"
            >手册页</a>）</span>
        </p>
        <p class="idl-code">
            <a name="COMPRESSEDTEXSUBIMAGE2D">void compressedTexSubImage2D</a>(GLenum target, GLint level,
            GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, ArrayBufferView pixels)
            <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.3">OpenGL ES2.0§3.7.3</a>，<a
                    class="nonnormative"
                    href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompressedTexSubImage2D.xml"
            >手册页</a>）</span>
        </p>
    </dt>
    <dd>
        如果尝试在没有绑定WebGLTexture的情况下调用这些函数（参见上文），
        则会生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        核心WebGL规范未定义任何支持的压缩纹理格式。默认情况下，这些方法会生成<code>INVALID_ENUM</code>错误
        并立即返回。请参阅
        <a href="#COMPRESSED_TEXTURE_SUPPORT">压缩纹理支持</a>。
    </dd>
    <dt class="idl-code">void copyTexImage2D(GLenum target, GLint level, GLenum internalformat,
        GLint x, GLint y, GLsizei width, GLsizei height,
        GLint border)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES2.0§3.7.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCopyTexImage2D.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），
        则会生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        对于位于帧缓冲区外的任何像素，相关纹素的所有通道都被初始化为0;
        请参阅<a href="#READS_OUTSIDE_FRAMEBUFFER">在Framebuffer之外阅读像素</a>。
        <br><br>
        如果此函数尝试从缺少附件的完整帧缓冲区中读取，则每次
        <a href="#READING_FROM_MISSING_ATTACHMENT">
            从缺少的附件读取</a>时会生成<code>INVALID_OPERATION</code>错误。
    </dd>
    <dt class="idl-code">void copyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset,
        GLint x, GLint y, GLsizei width, GLsizei height)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES2.0§3.7.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCopyTexSubImage2D.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），
        <code>INVALID_OPERATION</code>则会生成错误。<br><br>

        对于位于帧缓冲区外的任何像素，相关纹素的所有通道都被初始化为0;
        请参阅<a href="#READS_OUTSIDE_FRAMEBUFFER">在Framebuffer之外阅读像素</a>。<br><br>

        如果此函数尝试从缺少附件的完整帧缓冲区中读取，则每次<a href="#READING_FROM_MISSING_ATTACHMENT">
        从缺失附件中读取</a>时会生成<code>INVALID_OPERATION</code>错误。
    </dd>
    <dt class="idl-code">WebGLTexture? createTexture()
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES2.0§3.7.13</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenTextures.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        创建一个WebGLTexture对象并使用纹理对象名称对其进行初始化，就类似于调用glGenTextures。
    </dd>
    <dt class="idl-code">void deleteTexture(WebGLTexture? texture)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.13">OpenGL ES2.0§3.7.13</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteTextures.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        删除传递的WebGLTexture中包含的纹理对象，就类似于调用glDeleteTextures。
        如果纹理已被删除，则调用无效。请注意，销毁WebGLTexture对象时将删除纹理对象。
        这个方法只是让作者更好地控制纹理对象何时被销毁。
    </dd>
    <dt class="idl-code">void generateMipmap(GLenum target)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.11">OpenGL ES2.0§3.7.11</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGenerateMipmap.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），则
        则会生成<code>INVALID_OPERATION</code>错误。
    </dd>
    <dt class="idl-code">any getTexParameter(GLenum target, GLenum pname)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.3">OpenGL ES2.0§6.1.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetTexParameter.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        给定传递的目标返回传递的pname的值。返回的类型是请求的pname的自然类型，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>pname
                </th>
                <th>returned type
                </th>
            </tr>
            <tr>
                <td>
                    TEXTURE_MAG_FILTER
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    TEXTURE_MIN_FILTER
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>TEXTURE_WRAP_S
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>TEXTURE_WRAP_T
                </td>
                <td>GLenum
                </td>
            </tr>
            </tbody>
        </table>
        <p>
            如果<em>pname</em>不在上表中，则生成一个<code>INVALID_ENUM</code>错误。
        </p>
        <p>如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），则生成一个
            <code>INVALID_OPERATION</code>错误。
        </p>
        <p>
            如果生成OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isTexture(WebGLTexture? texture)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.4">OpenGL ES2.0§6.1.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsTexture.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果传递的WebGLTexture有效则返回true，否则返回false。<br><br>
        如果设置了纹理的
        <a href="#webgl-object-invalidated-flag">
            无效标志</a>则返回false。
    </dd>
    <dt class="idl-code">
        <a name="TEXIMAGE2D">void texImage2D</a>(GLenum target, GLint level, GLenum internalformat,
        GLsizei width, GLsizei height, GLint border, GLenum format,
        GLenum type, ArrayBufferView? pixels)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.1">OpenGL ES2.0§3.7.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexImage2D.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果<code>pixels</code>为null，则传递初始化为0的足够大小的缓冲区。
        <br><br>
        如果<code>pixels</code>为非null，则<code>pixels</code>的类型必须与要读取的数据类型匹配。
        如果是UNSIGNED_BYTE，则必须提供Uint8Array;
        如果是UNSIGNED_SHORT_5_6_5，UNSIGNED_SHORT_4_4_4_4或UNSIGNED_SHORT_5_5_5_1，则必须提供Uint16Array。
        如果类型不匹配，则会生成INVALID_OPERATION错误。
        <br><br>
        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），
        则会生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        用于影响此函数行为的WebGL特定像素存储参数请参阅
        <a href="#PIXEL_STORAGE_PARAMETERS">像素存储参数</a>
    </dd>
    <dt><p class="idl-code">
        <a name="TEXIMAGE2D_HTML">void texImage2D</a>(GLenum target, GLint level, GLenum internalformat,
        GLenum format, GLenum type, TexImageSource? source) /* May throw DOMException */
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.1">OpenGL ES2.0§3.7.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexImage2D.xml"
        >手册页</a>）</span>
    </p>
    </dt>
    <dd>
        将给定元素或图像数据上载到当前绑定的WebGLTexture。
        <br><br>
        纹理的宽度和高度按照
        <a href="#TEXTURE_UPLOAD_SIZE">
            纹理上载宽度和高度</a>部分中的设置进行设置。
        <br><br>

        源图像数据在概念上首先转换为由<em>format</em>和<em>type</em>参数指定的数据类型和格式，
        然后传输到WebGL实现。如果指定了打包像素格式，这意味着图像数据会丢失精度位，则这种精度损失一定会发生。
        <br><br>

        从源传输到WebGL实现的第一个像素对应于源的左上角。可以通过<code>UNPACK_FLIP_Y_WEBGL</code>
        <a href="#PIXEL_STORAGE_PARAMETERS">
            像素存储参数</a>修改此行为。
        <br><br>

        如果源图像是RGB或RGBA无损图像，每个通道8位，浏览器保证所有通道的完整精度得以保留。
        <br><br>

        如果原始图像包含alpha通道且<code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>像素存储参数为false，
        则保证RGB值永远不会被Alpha通道预乘，无论这些值是直接从原始文件格式派生还是从其他颜色格式转换而来。
        <br><br>

        <div class="note">
            HTMLCanvasElement的CanvasRenderingContext2D的一些实现以预乘形式在内部存储颜色值。
            如果将此类canvas上传到WebGL纹理且<code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>像素存储参数设置为false，
            则颜色通道一定不会与alpha通道相乘，这是一种有损操作。因此，WebGL实现无法保证在首次通过
            CanvasRenderingContext2D绘制到canvas，然后在上传到WebGL纹理时还能无损保留alpha&lt;1.0的颜色，
            当<code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>像素存储参数设置为false。
        </div>


        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），
        则会生成<code>INVALID_OPERATION</code>错误。
        <br><br>

        如果用于包含文档源不同源的<code>HTMLImageElement</code>或<code>HTMLVideoElement</code>或
        <i>origin-clean</i>标志被设置为false的<code>HTMLCanvasElement</code>作为参数调用此函数，
        一个<code>SECURITY_ERR</code>异常必须被抛出。请参阅
        <a href="#ORIGIN_RESTRICTIONS">源限制</a>。
        <br><br>

        如果<code>source</code>为null，则生成<code>INVALID_VALUE</code>错误。
        <br><br>

        有关影响此函数行为的WebGL特定像素存储参数，请参阅
        <a href="#PIXEL_STORAGE_PARAMETERS">
            像素存储参数</a>。
    </dd>
    <dt class="idl-code">void texParameterf(GLenum target, GLenum pname, GLfloat param)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.4">OpenGL ES2.0§3.7.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexParameter.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），
        则会生成<code>INVALID_OPERATION</code>错误。
    </dd>
    <dt class="idl-code">void texParameteri(GLenum target, GLenum pname, GLint param)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.4">OpenGL ES2.0§3.7.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexParameter.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），
        则会生成<code>INVALID_OPERATION</code>错误。
    </dd>
    <dt class="idl-code">
        <a name="TEXSUBIMAGE2D">void texSubImage2D</a>(GLenum target, GLint level, GLint xoffset, GLint yoffset,
        GLsizei width, GLsizei height,
        GLenum format, GLenum type, ArrayBufferView? pixels)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES2.0§3.7.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexSubImage2D.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        有关<em>format</em>和<em>pixels</em>参数的限制，请参阅
        <a href="#TEXIMAGE2D">texImage2D</a>。
        <br><br>
        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），
        则会生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        如果<em>type</em>与最初用于定义纹理的类型不匹配，
        则会生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        如果<code>pixels</code>为null，则生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        有关影响此函数行为的WebGL特定像素存储参数，请参阅
        <a href="#PIXEL_STORAGE_PARAMETERS">像素存储参数</a>。
    </dd>
    <dt><p class="idl-code">
        <a name="TEXSUBIMAGE2D_HTML">void
            texSubImage2D</a>void texSubImage2D</a>(GLenum target, GLint level, GLint xoffset, GLint yoffset,
        GLenum format, GLenum type, TexImageSource? source) /* May throw DOMException */
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-3.7.2">OpenGL ES2.0§3.7.2</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glTexSubImage2D.xml"
        >手册页</a>）</span>
    </p>
    </dt>
    <dd>
        使用给定元素或图像数据的内容更新当前绑定的WebGLTexture的子矩形。
        <br><br>
        更新的子矩形的宽度和高度按照
        <a href="#TEXTURE_UPLOAD_SIZE">
            纹理上载宽度和高度</a>部分中的指定确定
        。
        <br><br>
        有关<em>format</em>和<em>type</em>参数的解释，请参阅
        <a href="#TEXIMAGE2D_HTML">texImage2D</a>，
        以及有关<code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>像素存储参数的说明。
        <br><br>
        从源传输到WebGL实现的第一个像素对应于源的左上角。可以通过<code>UNPACK_FLIP_Y_WEBGL</code>
        <a href="#PIXEL_STORAGE_PARAMETERS">像素存储参数</a>
        修改此行为<br><br><code>UNPACK_FLIP_Y_WEBGL</code>。
        <br><br>
        如果尝试在没有绑定WebGLTexture的情况下调用此函数（参见上文），
        则会生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        如果<em>type</em>与最初用于定义纹理的类型不匹配，
        则会生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        如果用于包含文档源不同源的<code>HTMLImageElement</code>或<code>HTMLVideoElement</code>或
        <i>origin-clean</i>标志被设置为false的<code>HTMLCanvasElement</code>作为参数调用此函数，
        一个<code>SECURITY_ERR</code>异常必须被抛出。请参阅
        <a href="#ORIGIN_RESTRICTIONS">源限制</a>。
        <br><br>
        如果<code>source</code>为null，则生成<code>INVALID_VALUE</code>错误。
        <br><br>
        有关影响此函数的行为的具体WebGL的像素存储参数,请参阅
        <a href="#PIXEL_STORAGE_PARAMETERS">像素存储参数</a>。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.9">程序和着色器</h4>

<p>
    使用OpenGL ES 2.0进行渲染需要使用以OpenGL ES的着色器语言GLSL ES编写的<i>着色器</i>。
    着色器必须加载源字符串（shaderSource），编译（compileShader）并附加到<i>program</i>（attachShader），
    该<i>program</i>必须被链接（linkProgram）然后被使用（useProgram）。
</p>

<dl class="methods">
    <dt class="idl-code">void attachShader(WebGLProgram? program, WebGLShader? shader)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glAttachShader.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void bindAttribLocation(WebGLProgram? program, GLuint index, DOMString name)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES2.0§2.10.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glBindAttribLocation.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果传递的名称长于
        <a href="#MAX_LOCATION_LENGTHS">
            最大Uniform和Attribute位置长度</a>中定义的限制，则会生成<code>INVALID_VALUE</code>错误。
        <br><br>

        如果<code>name</code>以保留的WebGL前缀
        <a href="#GLSL_CONSTRUCTS">GLSLConstructs</a>
        开始，则生成<code>INVALID_OPERATION</code>错误。
        <br><br>

        WebGL实现执行的其他验证,请参阅
        <a href="#CHARACTERS_OUTSIDE_VALID_SET">
            GLSL源字符集外的字符</a>。
    </dd>
    <dt class="idl-code">void compileShader(WebGLShader? shader)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES2.0§2.10.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCompileShader.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        请参阅<a href="#SUPPORTED_GLSL_CONSTRUCTS">支持的GLSL构造</a>，
        <a href="#MAX_GLSL_TOKEN_SIZE">最大GLSL令牌大小</a>，
        <a href="#CHARACTERS_OUTSIDE_VALID_SET">GLSL源字符集外的字符</a>，
        <a href="#MAX_STRUCT_NESTING">GLSL着色器中结构的最大嵌套</a>，
        以及<a href="#PACKING_RESTRICTIONS">Uniforms和Varyings的打包限制</a>
        来了解附加的强制约定,附加常量和WebGl实现执行的附加验证。
    </dd>
    <dt class="idl-code">WebGLProgram? createProgram()
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateProgram.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        创建一个WebGLProgram对象并使用程序对象名称对其进行初始化，就类似于调用glCreateProgram。
    </dd>
    <dt class="idl-code">WebGLShader? createShader(GLenum type)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES2.0§2.10.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glCreateShader.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        创建一个WebGLShader对象并使用着色器对象名称对其进行初始化，就类似于调用glCreateShader。

    </dd>
    <dt class="idl-code">void deleteProgram(WebGLProgram? program)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteProgram.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        删除传递的WebGLProgram中包含的程序对象，就类似于调用glDeleteProgram。
        如果该程序已被删除，则该调用无效。请注意，销毁WebGLProgram对象时将删除程序对象。
        这个方法只是让作者更好地控制程序对象何时被销毁。
    </dd>
    <dt class="idl-code">void deleteShader(WebGLShader? shader)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES2.0§2.10.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDeleteShader.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        删除传递的WebGLShader中包含的着色器对象，就类似于调用glDeleteShader。
        如果着色器已被删除，则调用无效。请注意，销毁WebGLShader对象时将删除着色器对象。
        这个方法只是让作者更好地控制着色器对象何时被销毁。
    </dd>
    <dt class="idl-code">void detachShader(WebGLProgram? program, WebGLShader? shader)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDetachShader.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">sequence&lt;WebGLShader&gt;? getAttachedShaders(WebGLProgram? program)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetAttachedShaders.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        <p>返回一个新对象，表示附加到传递程序的着色器列表。
        </p>

        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">any getProgramParameter(WebGLProgram? program, GLenum pname)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetProgramiv.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        给定传递的程序返回传递的pname的值。返回的类型是请求的pname的自然类型，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>pname
                </th>
                <th>returned type
                </th>
            </tr>
            <tr>
                <td>
                    DELETE_STATUS
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>
                    LINK_STATUS
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>VALIDATE_STATUS
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>
                    ATTACHED_SHADERS
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    ACTIVE_ATTRIBUTES
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>ACTIVE_UNIFORMS
                </td>
                <td>GLint</td>
            </tr>
            </tbody>
        </table>
        <p>
            如果<em>pname</em>不在上表中，则生成<code>INVALID_ENUM</code>错误并返回null。
        </p>
        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">DOMString? getProgramInfoLog(WebGLProgram? program)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetProgramInfoLog.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">any getShaderParameter(WebGLShader? shader, GLenum pname)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderiv.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        给定传递的着色器返回传递的pname的值。返回的类型是请求的pname的自然类型，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>pname
                </th>
                <th>returned type
                </th>
            </tr>
            <tr>
                <td>
                    SHADER_TYPE
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>
                    DELETE_STATUS
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>COMPILE_STATUS
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            </tbody>
        </table>
        <p>
            如果<em>pname</em>不在上表中，则生成<code>INVALID_ENUM</code>错误并返回null。
        </p>
        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">WebGLShaderPrecisionFormat getShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/docs/man/xhtml/glGetShaderPrecisionFormat.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        返回一个新的<code>WebGLShaderPrecisionFormat</code>对象描述指定着色器数字格式的范围和精度。
        shadertype值可以是FRAGMENT_SHADER或VERTEX_SHADER。
        precisiontype值可以是LOW_FLOAT，MEDIUM_FLOAT，HIGH_FLOAT，LOW_INT，MEDIUM_INT或HIGH_INT。
    </dd>
    <dt class="idl-code">DOMString? getShaderInfoLog(WebGLShader? shader)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderInfoLog.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">DOMString? getShaderSource(WebGLShader? shader)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetShaderSource.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isProgram(WebGLProgram? program)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsProgram.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果传递的WebGLProgram有效则返回true，否则返回false。<br><br>

        如果设置了程序的<a href="#webgl-object-invalidated-flag">
        无效标志</a>，则返回false 。
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLboolean isShader(WebGLShader? shader)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glIsShader.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果传递的WebGLShader有效则返回true，否则返回false。<br><br>

        如果设置了着色器的<a href="#webgl-object-invalidated-flag">
        无效标志</a>，则返回false 。
    </dd>
    <dt class="idl-code">void linkProgram(WebGLProgram? program)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glLinkProgram.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        有关WebGL实现中强制执行的其他约束以及执行的其他验证，请参阅
        <a href="#PACKING_RESTRICTIONS">
            Uniforms和Varyings的打包限制</a>。
    </dd>
    <dt class="idl-code">void shaderSource(WebGLShader? shader, DOMString source)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.1">OpenGL ES2.0§2.10.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glShaderSource.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        请参阅<a href="#SUPPORTED_GLSL_CONSTRUCTS">支持的GLSL构造</a>，
        <a href="#MAX_GLSL_TOKEN_SIZE">最大GLSL令牌大小</a>，
        <a href="#CHARACTERS_OUTSIDE_VALID_SET">GLSL源字符集外的字符</a>，
        <a href="#MAX_STRUCT_NESTING">GLSL着色器中结构的最大嵌套</a>，
        以及<a href="#PACKING_RESTRICTIONS">Uniforms和Varyings的打包限制</a>，
        来了解附加的强制约束，附加支持的结构和WebGL实现执行的附加验证。
    </dd>
    <dt class="idl-code">void useProgram(WebGLProgram? program)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.3">OpenGL ES2.0§2.10.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUseProgram.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void validateProgram(WebGLProgram? program)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.5">OpenGL ES2.0§2.10.5</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glValidateProgram.xml"
        >手册页</a>）</span>
    </dt>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.10">Uniforms 和 attributes</h4>

<p>
    着色器使用的值通过uniforms或顶点属性传递。
</p>

<dl class="methods">
    <dt class="idl-code">void disableVertexAttribArray(GLuint index)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES2.0§2.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDisableVertexAttribArray.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void enableVertexAttribArray(GLuint index)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES2.0§2.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glEnableVertexAttribArray.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        将索引<code>index</code>处的顶点属性启用。除了启用的顶点属性外，WebGL还在OpenGL ES 2.0之外施加了额外
        的规则; 请参阅
        <a href="#ATTRIBS_AND_RANGE_CHECKING">启用顶点属性和范围检查</a>。
    </dd>
    <dt class="idl-code">WebGLActiveInfo? getActiveAttrib(WebGLProgram? program, GLuint index)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES2.0§2.10.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetActiveAttrib.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        返回一个新<code>WebGLActiveInfo</code>对象，该对象描述传递的程序对象的传递索引处的顶点属性
        的大小，类型和名称。如果传递的索引超出范围，则生成<code>INVALID_VALUE</code>错误并返回null。

        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">WebGLActiveInfo? getActiveUniform(WebGLProgram? program, GLuint index)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES2.0§2.10.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetActiveUniform.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        返回一个新<code>WebGLActiveInfo</code>对象，该对象描述传递的程序对象的传递索引处的uniform
        的大小，类型和名称。如果传递的索引超出范围，则生成一个<code>INVALID_VALUE</code>错误并返回null。

        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLint getAttribLocation(WebGLProgram? program, DOMString name)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES2.0§2.10.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetAttribLocation.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果传递的名称长于
        <a href="#MAX_LOCATION_LENGTHS">
            最大Uniform和属性位置长度中</a>定义的限制，则生成<code>INVALID_VALUE</code>错误并返回-1。
        <br><br>

        如果<code>name</code>以保留的WebGL前缀
        <a href="#GLSL_CONSTRUCTS">GLSL构造</a>
        开始，则返回-1。
        <br><br>

        如果设置了上下文的
        <a href="#webgl-context-lost-flag">
            webgl上下文丢失标志，</a>则返回-1。
        <br><br>

        如果设置了传递的程序的
        <a href="#webgl-object-invalidated-flag">
            无效标志</a>，则生成<code>INVALID_OPERATION</code>错误并返回-1。
        <br><br>

        有关WebGL实现执行的其他附加验证，请参阅
        <a href="#CHARACTERS_OUTSIDE_VALID_SET">
        GLSL源字符集之外的字符</a>。
    </dd>
    <dt class="idl-code">any getUniform(WebGLProgram? program, WebGLUniformLocation? location)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetUniform.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        返回传递的程序中传递位置的uniform值。返回的类型取决于uniform类型，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>uniform type</th>
                <th>returned type
                </th>
            </tr>
            <tr>
                <td>boolean</td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>int</td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>float</td>
                <td>GLfloat
                </td>
            </tr>
            <tr>
                <td>VEC 2
                </td>
                <td>
                    Float32Array（含2个元素）
                </td>
            </tr>
            <tr>
                <td>ivec2
                </td>
                <td>
                    Int32Array（含2个元素）
                </td>
            </tr>
            <tr>
                <td>bvec2
                </td>
                <td>sequence &lt;GLboolean&gt;（包含2个元素）
                </td>
            </tr>
            <tr>
                <td>VEC3
                </td>
                <td>
                    Float32Array（含3个元素）
                </td>
            </tr>
            <tr>
                <td>ivec3
                </td>
                <td>
                    Int32Array（含3个元素）
                </td>
            </tr>
            <tr>
                <td>bvec3
                </td>
                <td>sequence &lt;GLboolean&gt;（包含3个元素）
                </td>
            </tr>
            <tr>
                <td>vec4
                </td>
                <td>
                    Float32Array（含4个元素）
                </td>
            </tr>
            <tr>
                <td>ivec4
                </td>
                <td>
                    Int32Array（含4个元素）
                </td>
            </tr>
            <tr>
                <td>bvec4
                </td>
                <td>sequence &lt;GLboolean&gt;（包含4个元素）
                </td>
            </tr>
            <tr>
                <td>MAT2
                </td>
                <td>
                    Float32Array（含4个元素）
                </td>
            </tr>
            <tr>
                <td>MAT3
                </td>
                <td>
                    Float32Array（含9个元素）
                </td>
            </tr>
            <tr>
                <td>MAT4
                </td>
                <td>
                    Float32Array（含16个元素）
                </td>
            </tr>
            <tr>
                <td>
                    sampler2D
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>
                    samplerCube
                </td>
                <td>GLint</td>
            </tr>
            </tbody>
        </table>
        <p>
            返回序列或类型化数组的所有查询每次都返回一个新对象。
        </p>
        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">WebGLUniformLocation? getUniformLocation(WebGLProgram? program, DOMString name)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES2.0§2.10.4</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetUniformLocation.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        <p>返回一个新的<code>WebGLUniformLocation</code>对象，表示程序对象中特定uniform变量的位置。
            如果name与传递的程序中的活动uniform变量不对应，则返回值为null。
        </p>

        <p>
            如果传递的名称长于
            <a href="#MAX_LOCATION_LENGTHS">
                最大uniform和属性位置长度</a>中定义的限制，则生成<code>INVALID_VALUE</code>错误并返回null。
        </p>

        <p>
            如果<code>name</code>以保留的WebGL前缀
            <a href="#GLSL_CONSTRUCTS">GLSL构造</a>
            开始，则返回null。
        </p>

        <p>
            有关WebGL实现执行的其他附加验证，请参阅
            <a href="#CHARACTERS_OUTSIDE_VALID_SET">
                GLSL源字符集之外的字符</a>。
        </p>

        <p>
            如果在执行此函数期间生成任何OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">any getVertexAttrib(GLuint index, GLenum pname)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetVertexAttrib.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        返回传递索引处pname有关的顶点属性的信息。返回的类型取决于请求的信息，如下表所示：
        <table class="foo">
            <tbody>
            <tr>
                <th>pname
                </th>
                <th>returned type
                </th>
            </tr>
            <tr>
                <td>VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
                </td>
                <td>
                    WebGLBuffer
                </td>
            </tr>
            <tr>
                <td>VERTEX_ATTRIB_ARRAY_ENABLED
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>VERTEX_ATTRIB_ARRAY_SIZE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>VERTEX_ATTRIB_ARRAY_STRIDE
                </td>
                <td>GLint</td>
            </tr>
            <tr>
                <td>VERTEX_ATTRIB_ARRAY_TYPE
                </td>
                <td>GLenum
                </td>
            </tr>
            <tr>
                <td>VERTEX_ATTRIB_ARRAY_NORMALIZED
                </td>
                <td>
                    GLboolean
                </td>
            </tr>
            <tr>
                <td>
                    CURRENT_VERTEX_ATTRIB
                </td>
                <td>
                    Float32Array（含4个元素）
                </td>
            </tr>
            </tbody>
        </table>
        <p>
            返回序列或类型化数组的所有查询每次都返回一个新对象。
        </p>
        <p>
            如果<em>pname</em>不在上表中，则生成<code>INVALID_ENUM</code>错误。
        </p>
        <p>
            如果生成OpenGL错误，则返回null。
        </p>
    </dd>
    <dt class="idl-code">[WebGLHandlesContextLoss] GLsizeiptr getVertexAttribOffset(GLuint index, GLenum pname)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-6.1.8">OpenGL ES2.0§6.1.8</a>，类似于<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glGetVertexAttribPointerv.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果设置了上下文的
        <a href="#webgl-context-lost-flag">
            webgl上下文丢失标志</a>，则返回0 。
    </dd>
    <dt><p class="idl-code">void uniform[1234][fi](WebGLUniformLocation? location, ...)</p>
        <p class="idl-code">void uniform[1234][fi]v(WebGLUniformLocation? location, ...)</p>
        <p class="idl-code">void uniformMatrix[234]fv(WebGLUniformLocation? location, GLboolean transpose, ...)
            <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.10.4">OpenGL ES2.0§2.10.4</a>，<a
                    class="nonnormative"
                    href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glUniform.xml"
            >手册页</a>）</span>
        </p>
    </dt>
    <dd>
        上面的每个uniform*函数都将指定的uniform或uniforms设置为所提供的值。如果传递的<code>location</code>
        值不为null并且之前未通过<code>getUniformLocation</code>调用从当前使用的程序中获取，
        则将生成<code>INVALID_OPERATION</code>错误。如果传递<code>location</code>为null，
        则传入的数据将被忽略，并且不会更改uniform变量。
        <br><br>
        如果传递给任何矢量形式（那些<code>v</code>结尾的）的数组具有无效长度，则将生成<code>INVALID_VALUE</code>错误。
        如果长度太短或不是指定类型的整数倍，则长度无效。
    </dd>
    <dt><p class="idl-code">void vertexAttrib[1234]f(GLuint indx, ...)</p>
        <p class="idl-code">void vertexAttrib[1234]fv(GLuint indx, ...)
            <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.7">OpenGL ES2.0§2.7</a>，<a
                    class="nonnormative"
                    href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glVertexAttrib.xml"
            >手册页</a>）</span>
        </p>
    </dt>
    <dd>
        将传递索引处的顶点属性设置为给定的常量值。通过<code>vertexAttrib</code>设置的值
        可以保证保证从带有<code>CURRENT_VERTEX_ATTRIB</code>参数的<code>getVertexAttrib</code>函数调用返回，
        即使有对<code>drawArrays</code>或<code>drawElements</code>的干扰调用。
    </dd>
    <dt class="idl-code">void vertexAttribPointer(GLuint indx, GLint size, GLenum type,
        GLboolean normalized, GLsizei stride, GLintptr offset)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES2.0§2.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glVertexAttribPointer.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        将当前绑定到ARRAY_BUFFER目标的WebGLBuffer对象分配给传递索引处的顶点属性。
        大小是每个属性的组件数。步幅和偏移量以字节为单位。传递的步幅和偏移量必须适合传递的类型和大小，
        否则将生成<code>INVALID_OPERATION</code>错误;
        请参阅<a href="#BUFFER_OFFSET_AND_STRIDE">
        缓冲区偏移和步幅要求</a>。如果offset为负，则会生成<code>INVALID_VALUE</code>错误。
        如果没有WebGL缓冲区绑定到ARRAY_BUFFER目标，则会生成<code>INVALID_OPERATION</code>错误。
        在WebGL中，支持的最大步幅为255;
        请参阅<a href="#VERTEX_STRIDE">
        顶点属性数据步幅</a>。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.11">
    <a name="WRITING_TO_THE_DRAWING_BUFFER">写入绘图缓冲区</a>
</h4>

<p>
    OpenGL ES 2.0的具有3个调用可以渲染到绘图缓冲器：<code>clear</code>，<code>drawArrays</code>
    和<code>drawElements</code>。此外，渲染可以指向绘图缓冲区或Framebuffer对象。当渲染指向绘图缓冲区时，
    进行3个渲染调用中的任何一个都会导致绘图缓冲区在下一次合成操作开始时呈现给HTML页面合成器。
</p>

<dl class="methods">
    <dt class="idl-code">void clear(GLbitfield mask)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.2.3">OpenGL ES2.0§4.2.3</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glClear.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void drawArrays(GLenum mode, GLint first, GLsizei count)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES2.0§2.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDrawArrays.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        如果<em>first</em>为负数，则会生成<code>INVALID_VALUE</code>错误。如果CURRENT_PROGRAM为null，
        则将生成<code>INVALID_OPERATION</code>错误。
    </dd>
    <dt class="idl-code">void drawElements(GLenum mode, GLsizei count, GLenum type, GLintptr offset)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-2.8">OpenGL ES2.0§2.8</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glDrawElements.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        使用当前绑定的元素数组缓冲区绘制。给定的偏移量以字节为单位，并且必须是给定类型大小的有效倍数，
        否则将生成<code>INVALID_OPERATION</code>错误;请参阅
        <a href="#BUFFER_OFFSET_AND_STRIDE">
            缓冲区偏移和步幅要求</a>。如果<code>count</code>大于零，则<code>WebGLBuffer</code>必须将非null
        绑定到<code>ELEMENT_ARRAY_BUFFER</code>绑定点，否则将生成<code>INVALID_OPERATION</code>错误。
        <br><br>
        如果CURRENT_PROGRAM为null，则将生成<code>INVALID_OPERATION</code>错误。在调用<code>drawArrays</code>
        和<code>drawElements</code>时，WebGL执行超出OpenGL ES 2.0中指定的额外错误检查。请参见
        <a href="#ATTRIBS_AND_RANGE_CHECKING">
            启用顶点属性和范围检查</a>。
    </dd>
    <dt class="idl-code">void finish()
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.1">OpenGL ES2.0§5.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFinish.xml"
        >手册页</a>）</span>
    </dt>
    <dt class="idl-code">void flush()
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-5.1">OpenGL ES2.0§5.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glFlush.xml"
        >手册页</a>）</span>
    </dt>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.12">
    <a name="readpixels">读回像素</a>
</h4>

<p>
    当前帧缓冲区中的像素可以读回到ArrayBufferView对象中。
</p>

<dl class="methods">
    <dt class="idl-code">void readPixels(GLint x, GLint y, GLsizei width, GLsizei height,
        GLenum format, GLenum type, ArrayBufferView? pixels)
        <span class="gl-spec">（<a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf#nameddest=section-4.3.1">OpenGL ES2.0§4.3.1</a>，<a
                class="nonnormative"
                href="http://www.khronos.org/opengles/sdk/2.0/docs/man/xhtml/glReadPixels.xml"
        >手册页</a>）</span>
    </dt>
    <dd>
        使用帧缓冲区的指定矩形中的像素数据填充<code>pixels</code>。从readPixels返回的数据必须是
        最新发送绘图命令时的最新数据。
        <br><br>

        类型<code>pixels</code>必须与要读取的数据类型匹配。例如，如果是UNSIGNED_BYTE，则必须提供Uint8Array;
        如果是UNSIGNED_SHORT_5_6_5，UNSIGNED_SHORT_4_4_4_4或UNSIGNED_SHORT_5_5_5_1，则必须提供Uint16Array。
        如果类型不匹配，则会生成INVALID_OPERATION错误。
        <br><br>

        只有两种<code>format</code>和<code>type</code>的组合被接受。第一种是<code>format</code>RGBA和
        <code>type</code>UNSIGNED_BYTE。第二种是实现选择的格式。<code>format</code>和<code>type</code>
        的值可以通过调用
        <a href="#GETPARAMETER">
            <code>getParameter</code></a>来确定,分别使用符号常量IMPLEMENTATION_COLOR_READ_FORMAT和
        IMPLEMENTATION_COLOR_READ_TYPE作为参数。实现选择的格式可以根据当前绑定的渲染接口的格式而变化。
        不支持的<code>format</code>和<code>type</code>组合将生成INVALID_OPERATION错误。
        <br><br>

        如果<code>pixels</code>为null，则生成INVALID_VALUE错误。如果<code>pixels</code>是非空的，
        但是不足以在考虑像素存储模式的情况下检索指定矩形中的所有像素，生成INVALID_OPERATION错误。
        <br><br>

        对于位于帧缓冲区外的任何像素，读取的值在所有通道中包含0;
        请参阅<a href="#READS_OUTSIDE_FRAMEBUFFER">
        在Framebuffer之外阅读像素</a>。
        <br><br>

        如果此函数尝试从缺少颜色附件的完整帧缓冲区中读取，则每次
        <a href="#READING_FROM_MISSING_ATTACHMENT">
            从缺失附件中读取时</a>会生成<code>INVALID_OPERATION</code>错误。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.13">检测上下文丢失事件</h4>

<p>
    诸如移动设备上的电源事件之类的事件可能导致WebGL渲染上下文随时丢失，并且需要应用程序重建它;
    有关更多详细信息，请参阅
    <a href="#WEBGLCONTEXTEVENT">WebGLContextEvent</a>。
    以下方法有助于检测上下文丢失事件。
</p>

<dl class="methods">
    <dt class="idl-code">[WebGLHandlesContextLoss] boolean isContextLost()
    </dt>
    <dd>
        如果设置了<a href="#webgl-context-lost-flag">
        webgl上下文丢失标志</a>，则返回true，否则返回false。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h4 id="5.14.14">检测和启用扩展</h4>

<p>
    在没有首先通过扩展机制启用该功能的情况下，WebGL的实现不得支持任何其他参数，常量或函数。该
    <code>getSupportedExtensions</code>函数返回此实现支持的扩展字符串数组。通过将其中一个字符串传
    递给<code>getExtension</code>函数来启用扩展。此调用返回一个对象，该对象包含该扩展定义的任何常量或函数。
    该对象的定义特定于扩展，必须由扩展规范定义。
</p>
<p>
    启用扩展后，只有在WebGL渲染上下文丢失时才会禁用它（见下文），但“WEBGL_lose_context”扩展除外，
    它通过任何上下文丢失保持活动状态。禁用的扩展引用的任何对象（例如<code>getExtension</code>返回的对象）
    都不再与WebGL呈现上下文相关联。派生的任何扩展对象<code>WebGLObject</code>都将其
    <a href="#webgl-object-invalidated-flag">无效</a>
    标志设置为true。使用已禁用的扩展或其引用的对象会生成INVALID_OPERATION错误。
</p>
<p>
    没有其他机制可以禁用扩展。
</p>
<p>
    使用相同的扩展字符串进行对<code>getExtension</code>多次调用（考虑到不区分大小写的比较），
    只要启用了扩展，就必须返回相同的对象。尝试使用扩展的任何功能而不先调用getExtension来启用它
    必须生成适当的GL错误，并且不得使用该功能。
</p>
<p>
    此规范未定义任何扩展。单独的
    <a href="#refsREGISTRY">WebGL扩展注册表</a>
    定义了特定WebGL实现可能支持的扩展。
</p>

<dl class="methods">
    <dt class="idl-code">sequence&lt;DOMString&gt;? getSupportedExtensions()）
    </dt>
    <dd>
        返回所有支持的扩展字符串的列表。

    </dd>
    <dt class="idl-code">object? getExtension(DOMString name)
    </dt>
    <dd>
        如果返回一个对象，且仅当<em>name</em>是一个
        <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/infrastructure.html#ascii-case-insensitive">
            ASCII不区分大小写</a>
        <a href="#refsHTML">[HTML]</a>的匹配，
        <code>getSupportedExtensions</code>会返回所有可用的名称;
        否则，返回<code>null</code>。<code>getExtension</code>返回的对象包含扩展提供的任何常量或函数。
        如果扩展未定义任何常量或函数，则返回的对象可能没有常量或函数，但仍必须返回唯一对象。
        该对象用于指示已启用扩展。
    </dd>
</dl>

<!-- ======================================================================================================= -->

<h3 id="5.15">
    <a name="WEBGLCONTEXTEVENT">WebGLContextEvent</a>
</h3>

<p>
    WebGL生成一个<code>WebGLContextEvent</code>事件，以响应与HTMLCanvasElement相关联的WebGL呈现上下文的
    状态更改，该HTMLCanvasElement具有此事件的侦听器。使用DOM事件系统
    <a href="#refsDOM3EVENTS">[DOM3EVENTS]</a>
    发送事件。事件类型可以包括状态的丢失或恢复，或者无法创建上下文。
    <a href="http://www.w3.org/TR/domcore/#eventinit">EventInit</a>在DOM4
    <a href="#refsDOM4">[DOM4]</a>规范中定义。
</p>
    <b><a name="fire-a-webgl-context-event">引发名为e的WebGL的上下文事件</a></b>意味着一个
    <a href="http://www.w3.org/TR/domcore/#concept-event">事件</a>使用了<code>WebGLContextEvent</code>接口，
    其<a href="http://www.w3.org/TR/domcore/#dom-event-type"><code>type</code></a>属性
    <a href="#refsDOM4">[DOM4]</a>初始化为<em>e</em>，其
    <code>cancelable</code>属性初始化为true，并且其<a href="http://www.w3.org/TR/domcore/#dom-event-istrusted">
        <code>isTrusted</code></a>
    属性<a href="#refsDOM4">[DOM4]</a>初始化为true，
    将被<a href="http://www.w3.org/TR/domcore/#concept-event-dispatch">分派</a>到给定的对象。
<p>
</p>
<pre class="idl">
    [Constructor(DOMString type, optional WebGLContextEventInit eventInit)]
    interface <dfn id="WebGLContextLostEvent">WebGLContextEvent</dfn> : <a href="http://www.w3.org/TR/domcore/#event">Event</a> {
        readonly attribute DOMString statusMessage;
    };

    // EventInit是在DOM4规格中定义的.
    dictionary WebGLContextEventInit : <a href="http://www.w3.org/TR/domcore/#eventinit">EventInit</a> {
        DOMString statusMessage;
    };
</pre>

<p>
    本节中所有
    <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#queue-a-task">排队任务</a>
    <a href="#refsHTML">[HTML]</a>的
    <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#concept-task">任务</a>
    <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#task-source">源</a>
    都是<b>WebGL任务源</b>。
</p>

<h4 id="5.15.1">属性</h4>

<p>
    可以使用以下属性：
</p>

<dl class="methods">
    <dt>
        <span class="prop-name"><code>statusMessage</code></span>
        类型 <code>DOMString</code>
    </dt>
    <dd>
        包含附加信息的字符串，如果没有可用的附加信息，则为空字符串。
    </dd>
</dl>

<h4 id="5.15.2">
    <a name="CONTEXT_LOST">上下文丢失事件</a>
</h4>

<p>
    当用户代理检测到与<em>绘图缓冲区</em>关联的<em>上下文</em><code>WebGLRenderingContext</code>已丢失时，
    它必须运行以下步骤：
</p>
<ol class="nestedlist">

    <li>
        让<em>canvas</em>成为<em>context</em>的
        <a href="#context-canvas">canvas</a>。
    </li>

    <li>
        如果设置了context的
        <a href="#webgl-context-lost-flag">
            webgl上下文丢失</a>标志，则中止这些步骤。
    </li>

    <li>
        设置<em>context</em>的
        <a href="#webgl-context-lost-flag">
            webgl上下文丢失</a>标志。
    </li>

    <li>
        设置此上下文创建的每个<code>WebGLObject</code>实例的
        <a href="#webgl-object-invalidated-flag">
            无效标志</a>。
    </li>

    <li>
        禁用除“WEBGL_lose_context”之外的所有扩展。
    </li>

    <li>
        <a href="http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">任务排队</a>将执行以下步骤：

        <ol class="nestedlist">

            <li>
                <a href="#fire-a-webgl-context-event"></a>
                在<em>canvas</em>上触发名为“webglcontextlost”的
                <a href="#fire-a-webgl-context-event">
                    WebGL上下文事件</a>，其<code>statusMessage</code>属性设置为“”。
            </li>

            <li>
                如果未设置事件的
                <a href="http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#canceled-flag">已取消标志</a>，
                则中止这些步骤。
            </li>

            <li> 异步执行以下步骤。
            </li>

            <li>
                等待可恢复的<em>绘图缓冲区</em>。
            </li>

            <li>
                为<em>context</em>排队一个任务用于
                <a href="#restore-the-drawing-buffer">
                恢复绘图缓冲</a>。
            </li>
        </ol>
    </li>
</ol>
<p></p>
<div class="example">
    以下代码可防止<code>webglcontextlost</code>事件的默认行为并使<code>webglcontextrestored</code>
    事件能够传递：
    <pre>
        canvas.addEventListener("webglcontextlost", function(e) { e.preventDefault(); }, false);
    </pre>
</div>

<h4 id="5.15.3">上下文恢复事件</h4>

<p>
    当用户代理为<code>WebGLRenderingContext</code><em>context</em>
    <b><a name="restore-the-drawing-buffer">恢复绘制缓冲区</a></b>，它必须执行下列步骤：
</p>
<ol class="nestedlist">

    <li>
        让<em>canvas</em>成为与<em>context</em>关联的canvas对象。
    </li>
    <li>
        如果未设置<em>context</em>的
        <a href="#webgl-context-lost-flag">
            webgl上下文丢失标志</a>，则中止这些步骤。

    </li>
    <li>
        使用<em>context</em>的<a href="#context-creation-parameters">
        上下文创建参数</a>中指定的设置<a href="#create-a-drawing-buffer">
        创建<em>绘图缓冲区</em></a>，并将<em>绘图缓冲区</em>与<em>context</em>关联起来，丢弃以前的任何<em>绘图缓冲区</em>。
    </li>
    <li>
        清除<em>context</em>的<a href="#webgl-context-lost-flag">
        webgl上下文丢失标志</a>。
    </li>
    <li>
        重置<em>context</em>的
        OpenGL错误状态。
    </li>
    <li>
        在<em>canvas</em>上触发名为“webglcontextrestored”的
        <a href="#fire-a-webgl-context-event">
            WebGL上下文事件</a>，并将其<code>statusMessage</code>属性设置为“”。
    </li>
</ol>

<p></p>

<div class="note">
    恢复上下文后，在上下文丢失之前创建的WebGL资源（如纹理和缓冲区）不再有效。应用程序需要重新初始化上下文
    的状态并重新创建所有此类资源。
</div>

<div class="example">
    以下代码说明了应用程序如何处理上下文丢失和恢复：

    <pre>
        function initializeGame() {
          initializeWorld();
          initializeResources();
        }

        function initializeResources() {
          initializeShaders();
          initializeBuffers();
          initializeTextures();

          // 准备绘制，启动主循环
          renderFrame();
        }

        function renderFrame() {
          updateWorld();
          drawSkyBox();
          drawWalls();
          drawMonsters();

          requestId = window.requestAnimationFrame(
              renderFrame, canvas);
        }

        canvas.addEventListener(
            "webglcontextlost", function (event) {

          // 通知WebGL让我们来处理上下文恢复
          event.preventDefault();

          // 停止渲染
          window.cancelAnimationFrame(requestId);
        }, false);

        canvas.addEventListener(
            "webglcontextrestored", function (event) {

          initializeResources();
        }, false);

        initializeGame();
    </pre>
</div>

<h4 id="5.15.4">上下文创建错误事件</h4>

<p>
    当用户代理要在<em>canvas</em>上<b><a name="fire-a-webgl-context-creation-error">
    触发WebGL上下文创建错误</a></b>时，它必须执行以下步骤：
</p>
<ol class="nestedlist">

    <li>
        在<em>canvas</em>上触发名为“webglcontextcreationerror”的
        <a href="#fire-a-webgl-context-event">
            WebGL上下文事件</a>，可选地将其<code>statusMessage</code>属性设置为与平台相关的字符串，
        该字符串与故障的性质有关。
    </li>

</ol>

<p></p>

<div class="example">

    以下代码说明了应用程序如何检索有关上下文创建失败的信息：
    <pre>
        var errorInfo = "";
        function onContextCreationError(event) {
          canvas.removeEventListener(
             "webglcontextcreationerror",
             onContextCreationError, false);

          errorInfo = e.statusMessage || "Unknown";
        }

        canvas.addEventListener(
            "webglcontextcreationerror",
            onContextCreationError, false);

        var gl = canvas.getContext("experimental-webgl");
        if(!gl) {
          alert("无法创建WebGL上下文.\n原因: " + errorInfo);
        }
    </pre>
</div>

<!-- ======================================================================================================= -->

<h2 id="6">
    <a name="webgl_gl_differences">WebGL和OpenGL ES 2.0之间的差异</a>
</h2>

<p>
    本节介绍了相对于OpenGL ES 2.0 API对WebGL API所做的更改，以提高跨各种操作系统和设备的可移植性。
</p>

<h3 id="6.1">
    <a name="BUFFER_OBJECT_BINDING">缓冲区对象绑定</a>
</h3>

<p>
    在WebGL API中，给定的缓冲区对象在其生命周期中只能绑定到<code>ARRAY_BUFFER</code>或
    <code>ELEMENT_ARRAY_BUFFER</code>其中一个绑定点。此限制意味着给定的缓冲区对象可能包含顶点或索引，
    但不能同时包含两者。
</p>
<p>
    WebGLBuffer的类型在第一次作为参数传递给<code>bindBuffer</code>时初始化。后续调用<code>bindBuffer</code>
    尝试将同一WebGLBuffer绑定到另一个绑定点时将生成<code>INVALID_OPERATION</code>错误，并且绑定点的状态将
    保持不变。
</p>

<h3 id="6.2">没有客户端数组</h3>

<p>
    WebGL API不支持客户端数组。如果<code>vertexAttribPointer</code>在没有<code>WebGLBuffer</code>对象被绑定
    到<code>ARRAY_BUFFER</code>绑定点的情况下调用，则会生成<code>INVALID_OPERATION</code>错误。
    如果调用<code>drawElements</code>时<code>count</code>参数大于零，并且没有<code>WebGLBuffer</code>对象被
    绑定到<code>ELEMENT_ARRAY_BUFFER</code>绑定点，则会生成<code>INVALID_OPERATION</code>错误。
</p>

<h3 id="6.3">无默认纹理</h3>

<p>
    WebGL API不支持默认纹理。必须绑定非null的<code>WebGLTexture</code>对象才能使与纹理相关的操作和查询成功。
</p>

<h3 id="6.4">
    <a name="BUFFER_OFFSET_AND_STRIDE">缓冲偏移和步幅要求</a>
</h3>

<p>
    <code>drawElements</code>和<code>vertexAttribPointer</code>的<code>offset</code>参数，
    和<code>vertexAttribPointer</code>的<code>stride</code>参数，必须是传递给该调用的数据类型的大小的
    整倍数，否则产生<code>INVALID_OPERATION</code>错误。
</p>


<h3 id="6.5">
    <a name="ATTRIBS_AND_RANGE_CHECKING">启用顶点属性和范围检查</a>
</h3>

<p>
    如果将顶点属性作为数组通过<code>enableVertexAttribArray</code>启用，但没有缓冲区通过<code>bindBuffer</code>
    和<code>vertexAttribPointer</code>绑定到该属性，则调用<code>drawArrays</code>或<code>drawElements</code>
    将生成<code>INVALID_OPERATION</code>错误。
</p>
<p>
    如果将顶点属性作为数组启用，并且有缓冲区绑定到该属性，并且该属性被当前程序使用了，然后调用
    <code>drawArrays</code>或<code>drawElements</code>是会验证绑定缓冲区内存储的每个引用的顶点。
    如果在<code>drawArrays</code>指定的范围或在<code>drawElements</code>任何引用的索引位于绑定缓冲区
    的存储区之外，则会生成INVALID_OPERATION错误，并且不会绘制几何图形。
</p>
<p>
    如果将顶点属性作为数组启用，则缓冲区绑定到该属性，但当前程序没有使用该属性，那么无论绑定缓冲区的大小如何，
    它都不会在调用<code>drawArrays</code>或<code>drawElements</code>期间生成任何错误。
</p>

<h3 id="6.6">
    <a name="FBO_ATTACHMENTS">帧缓冲对象附件</a>
</h3>

<p>
    WebGL添加了<code>DEPTH_STENCIL_ATTACHMENT</code>帧缓冲对象附着点和<code>DEPTH_STENCIL</code>
    渲染缓冲内部格式。要将深度和模板缓冲附加到帧缓冲对象，请使用<code>DEPTH_STENCIL</code>内部格式
    调用<code>renderbufferStorage</code>，然后使用<code>DEPTH_STENCIL_ATTACHMENT</code>附着点调用
    <code>framebufferRenderbuffer</code>。
</p>
<p>
    附加到<code>DEPTH_ATTACHMENT</code>附着点的渲染缓冲区必须使用<code>DEPTH_COMPONENT16</code>内部格式
    进行分配。附加到<code>STENCIL_ATTACHMENT</code>附着点的渲染缓冲区必须使用<code>STENCIL_INDEX8</code>
    内部格式进行分配。附加到<code>DEPTH_STENCIL_ATTACHMENT</code>附着点的渲染缓冲区必须使用
    <code>DEPTH_STENCIL</code>内部格式进行分配。
</p>
<p>
    在WebGL API中，将渲染缓冲区并发附加到以下附着点组合是错误的：
</p>
<ul>
    <li><code>DEPTH_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
    </li>
    <li><code>STENCIL_ATTACHMENT + DEPTH_STENCIL_ATTACHMENT</code>
    </li>
    <li><code>DEPTH_ATTACHMENT + STENCIL_ATTACHMENT</code>
    </li>
</ul>
如果违反了上述任何约束，则：
<ul>
    <li>
        <code>checkFramebufferStatus</code>必须返回<code>FRAMEBUFFER_UNSUPPORTED</code>。
    </li>
    <li>
        以下调用（修改或读取帧缓冲区）必须生成<code>INVALID_FRAMEBUFFER_OPERATION</code>错误并提前返回，
        保持帧缓冲区，目标纹理或目标内存的内容不变。
        <ul>
            <li> clear
            </li>
            <li> copyTexImage2D
            </li>
            <li> copyTexSubImage2D
            </li>
            <li> drawArrays
            </li>
            <li> drawElements
            </li>
            <li> readPixels
            </li>
        </ul>
    </li>
</ul>
帧缓冲对象附件的以下组合，当所有附件都是完整的帧缓冲附件，非零且具有相同的宽度和高度时，必须导致帧缓冲变成
完整帧缓冲：
<ul>
    <li>
        <code>COLOR_ATTACHMENT0</code>= <code>RGBA/UNSIGNED_BYTE</code>texture
    </li>
    <li>
        <code>COLOR_ATTACHMENT0</code>= <code>RGBA/UNSIGNED_BYTE</code>texture
        + <code>DEPTH_ATTACHMENT</code>= <code>DEPTH_COMPONENT16</code>renderbuffer
    </li>
    <li>
        <code>COLOR_ATTACHMENT0</code>= <code>RGBA/UNSIGNED_BYTE</code>texture
        + <code>DEPTH_STENCIL_ATTACHMENT</code>= <code>DEPTH_STENCIL</code>renderbuffer
    </li>
</ul>

<h3 id="6.7">
    <a name="TEXTURE_UPLOAD_SIZE">纹理上传宽度和高度</a>
</h3>

<p>
    除非<code>width</code>和<code>height</code>参数显式指定，纹理的宽度和高度
    由<code>texImage2D</code>设定，由更新<code>texSubImage2D</code>的子矩形宽度和高度
    基于上载<code>TexImageSource source</code>的对象被确定：
</p>

<dl>
    <dt><code>source</code>
        类型 <code>ImageData</code>
    </dt>
    <dd>
        纹理的宽度和高度设置为ImageData对象的width和height属性的当前值，表示<code>ImageData</code>对象的
        实际像素宽度和高度。
    </dd>
    <dt><code>source</code>
        类型 <code>HTMLImageElement</code>
    </dt>
    <dd>
        如果上载了位图，则纹理的宽度和高度将设置为上载的位图的宽度和高度（以像素为单位）。
        如果上载SVG图像，则纹理的宽度和高度将设置为<code>HTMLImageElement</code>对象的宽度和高度属性的当前值。
    </dd>
    <dt><code>source</code>
        类型 <code>HTMLCanvasElement</code>
    </dt>
    <dd>
        纹理的宽度和高度设置为<code>HTMLCanvasElement</code>对象
        的宽度和高度属性的当前值。
    </dd>
    <dt><code>source</code>
        类型 <code>HTMLVideoElement</code>
    </dt>
    <dd>
        纹理的宽度和高度设置为上传视频帧的宽度和高度（以像素为单位）。
    </dd>
</dl>

<h3 id="6.8">
    <a name="PIXEL_STORAGE_PARAMETERS">像素存储参数</a>
</h3>

<p>
    WebGL API支持以下附加参数<code>pixelStorei</code>。
</p>
<dl>
    <dt><code>UNPACK_FLIP_Y_WEBGL</code>
        类型 <code>boolean</code>
    </dt>
    <dd>
        如果设置为<code>true</code>，则在对<code>texImage2D</code>或<code>texSubImage2D</code>的
        任何后续调用期间，沿垂直轴翻转源数据，从概念上说，最后一行被转换为第一行。初始值是<code>false</code>。
        任何非零值都被解释为<code>true</code>。
    </dd>
    <dt>
        <code>UNPACK_PREMULTIPLY_ALPHA_WEBGL</code>
        类型 <code>boolean</code>
    </dt>
    <dd>
        如果设置为<code>true</code>，则在任何后续调用<code>texImage2D</code>或<code>texSubImage2D</code>
        期间，源数据的alpha通道（如果存在）在数据传输期间乘以颜色通道。初始值是<code>false</code>。
        任何非零值都被解释为<code>true</code>。
    </dd>
    <dt>
        <code>UNPACK_COLORSPACE_CONVERSION_WEBGL</code>
        类型 <code>unsigned long</code>
    </dt>
    <dd>
        如果设置为<code>BROWSER_DEFAULT_WEBGL</code>，则在后续<code>texImage2D</code>和
        <code>texSubImage2D</code>调用期间应用浏览器的默认颜色空间转换。精确的转换可能特定于
        浏览器和文件类型。如果设置为<code>NONE</code>，则不应用颜色空间转换。初始值是
        <code>BROWSER_DEFAULT_WEBGL</code>。
    </dd>
</dl>

<h3 id="6.9">
    <a name="READS_OUTSIDE_FRAMEBUFFER">读取帧缓冲区外的像素</a>
</h3>

<p>
    在WebGL API中，读取帧缓冲区（<code>copyTexImage2D</code>，<code>copyTexSubImage2D</code>和
    <code>readPixels</code>）的函数被被定义为这样，为绑定帧缓冲区之外的任何像素生成RGBA值（0,0,0,0）。
</p>

<h3 id="6.10">
    <a name="STENCIL_SEPARATE_LIMIT">模板分离遮盖和参考值</a>
</h3>

<p>
    在WebGL API中，在模板操作中为前向和后向三角形指定不同的遮盖或参考值是非法的。在以下情况下调用
    <code>drawArrays</code>或<code>drawElements</code>将产生<code>INVALID_OPERATION</code>错误：

</p>
<ul>
    <li>
        <code>STENCIL_WRITEMASK</code>！= <code>STENCIL_BACK_WRITEMASK</code>（
        由<code>stencilMaskSeparate</code>的<code>mask</code>参数指定,
        分别关联到FRONT和BACK<code>face</code>）
    </li>
    <li>
        <code>STENCIL_VALUE_MASK</code>！= <code>STENCIL_BACK_VALUE_MASK</code>（
        由<code>stencilFuncSeparate</code>的<code>mask</code>参数指定,
        分别关联到FRONT和BACK<code>face</code>）
    </li>
    <li><code>STENCIL_REF</code>！= <code>STENCIL_BACK_REF</code>（
        由<code>stencilFuncSeparate</code>的<code>ref</code>参数指定,
        分别关联到FRONT和BACK<code>face</code>）
    </li>
</ul>

<p></p>

<h3 id="6.11">
    <a name="VERTEX_STRIDE">顶点属性数据步幅</a>
</h3>

<p>
    WebGL API支持最多255个字节的顶点属性数据步幅。
    如果stride参数的值超过255，则调用<code>vertexAttribPointer</code>将生成<code>INVALID_VALUE</code>错误。
</p>

<h3 id="6.12">
    <a name="VIEWPORT_DEPTH_RANGE">视口深度范围</a>
</h3>

<p>
    WebGL API不支持这样的深度范围，其近平面的值大于远平面的值。
    如果<code>zNear</code>大于<code>zFar</code>，则调用<code>depthRange</code>将生成
    <code>INVALID_OPERATION</code>错误。
</p>

<h3 id="6.13">
    <a name="CONSTANT_COLOR_BLEND">与常量颜色混合</a>
</h3>

<p>
    在WebGL API中，常量颜色和常量alpha不能一起用作混合函数中的源和目标因子。调用<code>blendFunc</code>将产生
    一个<code>INVALID_OPERATION</code>错误,如果两个因素中的一个被设置为<code>CONSTANT_COLOR</code>
    或<code>ONE_MINUS_CONSTANT_COLOR</code>，另一个<code>CONSTANT_ALPHA</code>或
    <code>ONE_MINUS_CONSTANT_ALPHA</code>。如果<code>srcRGB</code>设置为<code>CONSTANT_COLOR</code>
    或<code>ONE_MINUS_CONSTANT_COLOR</code>，<code>dstRGB</code>设置为<code>CONSTANT_ALPHA</code>或者
    <code>ONE_MINUS_CONSTANT_ALPHA</code>，则调用<code>blendFuncSeparate</code>将生成
    <code>INVALID_OPERATION</code>错误，反之亦然。
</p>

<h3 id="6.14">定点支持</h3>

WebGL API不支持<code>GL_FIXED</code>数据类型。

<h3 id="6.15">
    <a name="GLSL_CONSTRUCTS">GLSL构造</a>
</h3>

<p>
    根据<a href="#SUPPORTED_GLSL_CONSTRUCTS">
    支持的GLSL构造</a>，以“webgl_”和“_webgl_”开头的标识符保留供WebGL使用。
</p>

<h3 id="6.16">
    <a name="EXTENSION_QUERIES">扩展查询</a>
</h3>

<p>
    在OpenGL ES 2.0 API中，可用的扩展通过调用<code>glGetString(GL_EXTENSIONS)</code>确定，
    它返回以空格分隔的扩展字符串列表。在WebGL API中，<code>EXTENSIONS</code>枚举已删除了。
    相反，必须调用<code>getSupportedExtensions</code>来确定可用扩展的集合。
</p>

<h3 id="6.17">
    <a name="COMPRESSED_TEXTURE_SUPPORT">压缩纹理支持</a>
</h3>

<p>
    核心WebGL规范未定义任何支持的压缩纹理格式。因此，在没有启用任何其他扩展的情况下：
</p>
<ul>

    <li>
        <a href="#COMPRESSEDTEXIMAGE2D"><code>compressedTexImage2D</code></a>
        和<a href="#COMPRESSEDTEXSUBIMAGE2D"><code>compressedTexSubImage2D</code></a>
        方法产生<code>INVALID_ENUM</code>错误。
    </li>

    <li>
        使用参数<code>COMPRESSED_TEXTURE_FORMATS</code>调用
        <a href="#GETPARAMETER">
            <code>getParameter</code></a>将返回零长度数组（<code>Uint32Array</code>类型）。
    </li>

</ul>
<p></p>

<h3 id="6.18">
    <a name="MAX_GLSL_TOKEN_SIZE">最大GLSL符号大小</a>
</h3>

<p>
    GLSL ES规范<a href="#refsGLES20GLSL">
    [GLES20GLSL]</a>没有定义符号长度的限制。
    WebGL需要支持最多256个字符的符号。包含超过256个字符的符号的着色器必须无法编译。
</p>

<h3 id="6.19">
    <a name="CHARACTERS_OUTSIDE_VALID_SET">
        GLSL源字符集外的字符</a>
</h3>

<p>
    GLSL ES规范<a href="#refsGLES20GLSL">[GLES20GLSL]</a>
    将OpenGL ES着色语言的源字符集定义为ISO / IEC 646：1991，通常称为ASCII
    <a href="#refsASCII">[ASCII]</a>。
    如果包含不在这个集合中的字符的字符串传递给任何着色器相关的入口点<code>bindAttribLocation</code>，
    <code>getAttribLocation</code>，<code>getUniformLocation</code>，或者<code>shaderSource</code>，
    会产生<code>INVALID_VALUE</code>错误。例外情况是HTML DOMString
    <a href="#refsDOMSTRING">[DOMSTRING]</a>中允许
    的任何字符都可以在GLSL注释中使用。这种使用不得产生错误。
</p>

<div class="note">
    <p>
        有些GLSL实现不允许ASCII范围之外的字符，即使在注释中也是如此。
        WebGL实现需要在这种情况下防止错误。推荐的技术是预处理GLSL字符串，删除所有注释，
        但通过根据需要插入换行符来维护行编号以进行调试。
    </p>
</div>

<h3 id="6.20">
    <a name="MAX_STRUCT_NESTING">GLSL着色器中结构的最大嵌套</a>
</h3>

<p>
    WebGL对GLSL着色器中的结构嵌套施加了限制。
    当结构中的字段引用另一个结构类型时，就会发生嵌套; GLSL ES规范
    <a href="#refsGLES20GLSL">[GLES20GLSL]</a>
    禁止嵌入式结构定义。顶级结构定义中的字段的嵌套级别为1。
</p>
<p>
    WebGL需要支持结构嵌套级别为4.包含嵌套超过4级深度的结构的着色器必须无法编译。
</p>

<h3 id="6.21">
    <a name="MAX_LOCATION_LENGTHS">最大Uniform和属性位置长度</a>
</h3>

<p>
    WebGL对Uniform和属性位置的长度施加了256个字符的限制。
</p>

<h3 id="6.22">
    <a name="STRING_LENGTH_QUERIES">字符串长度查询</a>
</h3>

<p>
    在WebGL API中，枚举<code>INFO_LOG_LENGTH</code>，<code>SHADER_SOURCE_LENGTH</code>，
    <code>ACTIVE_UNIFORM_MAX_LENGTH</code>，和<code>ACTIVE_ATTRIBUTE_MAX_LENGTH</code>已被删除。
    在OpenGL ES 2.0 API中，需要这些枚举来确定传递给调用的缓冲区的大小,比如<code>glGetActiveAttrib</code>。
    在WebGL API中，类似的调用（<code>getActiveAttrib</code>，<code>getActiveUniform</code>，
    <code>getProgramInfoLog</code>，<code>getShaderInfoLog</code>，和<code>getShaderSource</code>）
    都返回<code>DOMString</code>。
</p>

<h3 id="6.23">TexSubImage2D调用中的纹理类型</h3>

<p>
    在WebGL API中，传递给<code>texSubImage2D</code>的<em>type</em>参数必须与用于最初定义纹理对象的
    类型匹配（例如，使用<code>texImage2D</code>）。
</p>

<h3 id="6.24">
    <a name="PACKING_RESTRICTIONS">Uniforms和Varyings的打包限制</a>
</h3>

<p>
    OpenGL ES着色语言版本1.00 <a href="#refsGLES20GLSL">[GLES20GLSL]</a>，
    附录A，第7节“Varyings和Uniforms的计数”定义了一种保守算法，用于计算着色器中所有uniform变量和varying变量
    所需的存储空间。GLSL ES规范要求如果附录A中定义的打包算法成功，则着色器必须在目标平台上成功编译。WebGL API
    进一步要求如果打包算法对着色器的uniform变量或程序的varying变量失败，则编译或链接必须失败。
</p>
<p>
    不使用固定大小的寄存器网格，而是通过以下方式确定目标体系结构中的行数：
</p>
<ul>
    <li>
        在计数顶点着色器中计算uniform变量时： 使用<code>getParameter(MAX_VERTEX_UNIFORM_VECTORS)</code>
    </li>
    <li>
        在计数片元着色器中计算uniform变量时： 使用<code>getParameter(MAX_FRAGMENT_UNIFORM_VECTORS)</code>
    </li>
    <li> 计算varying时： 使用<code>getParameter(MAX_VARYING_VECTORS)</code>
    </li>
</ul>
<p></p>

<h3 id="6.25">纹理和帧缓冲之间的反馈循环</h3>
<p>
    在OpenGL ES 2.0 API中，可以在对相同纹理进行写入和读取的时候创建反馈循环。
    它指定存在这些反馈循环的位置，导致未定义的行为。
</p>
<p>
    在WebGL API中，这种导致此类反馈循环的操作（通过OpenGL ES
    2.0规范中的定义）将生成<code>INVALID_OPERATION</code>错误。
</p>

<h3 id="6.26">
    <a name="READING_FROM_MISSING_ATTACHMENT">从缺失的附件中读取</a>
</h3>
<p>
    在OpenGL ES 2.0 API中，未指定当命令尝试从缺少的附件中获取数据时发生的情况，
    例如使用ReadPixels从没有颜色附件的完整帧缓冲区读取颜色数据的。
</p>
<p>
    在WebGL API中，需要来自缺失附件的数据的此类操作将生成<code>INVALID_OPERATION</code>错误。
    这适用于以下功能：
</p>
<ul>
    <li><code>copyTexImage2D</code>
    </li>
    <li><code>copyTexSubImage2D</code>
    </li>
    <li><code>readPixels</code>
    </li>
</ul>
<p></p>

<h3 id="6.27">
    <a name="NAN_LINE_WIDTH"> NaN线宽</a>
</h3>
<p>
    在WebGL API中，如果传递给<code>lineWidth</code>的<code>width</code>参数设置为NaN，
    则会生成<code>INVALID_VALUE</code>错误并且不会更改线宽。
</p>

<h3 id="6.28">
    <a name="ATTRIBUTE_ALIASING">属性别名</a>
</h3>
<p>
    应用程序可以将多个属性名称绑定到同一位置。
    这称为别名。当多个属于同一位置的属性别名在可执行程序中处于活动状态时，<code>linkProgram</code>应该失败。
</p>

<!-- ======================================================================================================= -->

<h2 id="7">参考文献</h2>

<h3 id="7.1">规范性参考文献</h3>

<dl>
    <dt id="refsCANVAS">[CANVAS]
    </dt>
    <dd>
        <cite><a href="https://www.w3.org/TR/html5/scripting-1.html#the-canvas-element">
            HTML5：Canvas元素</a></cite>，万维网联盟（W3C）。
    </dd>

    <dt id="refsCANVASCONTEXTS">[CANVASCONTEXTS]
    </dt>
    <dd>
        <cite><a href="http://wiki.whatwg.org/wiki/CanvasContexts">
            canvas上下文注册表</a></cite>，WHATWG。
    </dd>
    <dt id="refsTYPEDARRAYS">
        [TYPEDARRAYS]
    </dt>
    <dd><cite><a href="http://www.khronos.org/registry/typedarray/specs/latest/">
        类型数组规范：编辑草稿</a></cite>，V。Vukicevic，K。Russell，2010年5月。
    </dd>
    <dt id="refsGLES20">
        [GLES20]
    </dt>
    <dd>
        <cite><a href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf">
            OpenGL® ES Common Profile Specification Version
            2.0.25</a></cite>，A。Munshi，J。Leech，2010年11月。
    </dd>
    <dt id="refsGLES20GLSL">
        [GLES20GLSL]
    </dt>
    <dd>
        <cite><a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">
            OpenGL®ES着色语言版本1.00</a></cite>，R。Simpson，2009年5月。
    </dd>
    <dt id="refsREGISTRY">
        [REGISTRY]
    </dt>
    <dd>
        <cite><a href="http://www.khronos.org/registry/webgl/extensions/">
            WebGL扩展注册表</a></cite>
    </dd>
    <dt id="refsRFC2119">[RFC2119]
    </dt>
    <dd>
        <cite><a href="http://www.ietf.org/rfc/rfc2119.txt">
            Key words for use in RFCs to Indicate Requirement Levels</a></cite>，
        S。Bradner。IETF，1997年3月。
    </dd>
    <dt id="refsCSS">[CSS]
    </dt>
    <dd>
        <cite><a href="http://www.w3.org/TR/CSS21/">
            层叠样式表2级修订版1（CSS
            2.1）规范</a></cite>，B。Bos，T。Celik，I。Hickson，HW
        Lie，2011年6月。
    </dd>
    <dt id="refsCORS">[CORS]
    </dt>
    <dd>
        <cite><a href="http://www.w3.org/TR/cors/">
            跨域资源共享</a></cite>，A。van
        Kesteren，2010年7月。
    </dd>
    <dt id="refsDOM4">[DOM4]
    </dt>
    <dd>
        <cite><a href="http://www.w3.org/TR/domcore/">
            DOM4</a></cite>，A。van
        Kesteren，A。Gregor，Ms2ger。
    </dd>
    <dt id="refsDOM3EVENTS">
        [DOM3EVENTS]
    </dt>
    <dd>
        <cite><a href="http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html">
            文档对象模型（DOM）Level 3 Events
            Specification</a></cite>，Doug
        Schepers和Jacob Rossi。W3C。
    </dd>
    <dt id="refsHTML">[HTML]
    </dt>
    <dd>
        <cite><a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/">
            HTML</a></cite>，I。Hickson，2011年6月。
    </dd>
    <dt id="refsWEBIDL">
        [WEBIDL]
    </dt>
    <dd>
        <cite><a href="http://dev.w3.org/2006/webapi/WebIDL/">
            Web IDL：W3C编辑的草案</a></cite>，C。McCormack。
    </dd>
    <dt id="refsASCII">
        [ASCII]
    </dt>
    <dd><cite>国际标准ISO / IEC
        646：1991。信息技术 - 用于信息交换的ISO 7位编码字符集</cite>
    </dd>
    <dt id="refsDOMSTRING">
        [DOMSTRING]
    </dt>
    <dd>
        <cite><a href="http://www.w3.org/TR/DOM-Level-2-Core/core.html#DOMString">
            文档对象模型核心：DOMString类型</a></cite>，万维网联盟（W3C）。
    </dd>
</dl>

<h3 id="7.2">其他参考文献</h3>

<!-- ======================================================================================================= -->

<h2 id="8">致谢</h2>

<p>该规范由Khronos WebGL工作组制作。
</p>

<p>
    特别感谢：Arun Ranganathan（Mozilla），Chris Marrin（Apple），Jon Leech，Ken​​neth Russell（谷歌），Kenneth Waters（谷歌），Mark
    Callow（HI），Mark Steele（Mozilla），Oliver Hunt（Apple），Tim Johansson（Opera），Vangelis Kokkevis（谷歌），Vladimir
    Vukicevic（Mozilla），Gregg Tavares（谷歌）
</p>
<p>
    还要感谢：Alan Hudson（Yumetech），Benoit Jacob（Mozilla），Bill Licea Kane（AMD），Boris Zbarsky（Mozilla），Cameron
    McCormack（Mozilla），Cedric Vivier（Zegami），Dan Gessel（Apple），David Ligon（ Qualcomm），David Sheets（Ashima Arts），Glenn
    Maynard，Greg Roth（Nvidia），Jacob Strom（爱立信），Jeff Gilbert（Mozilla），Kari Pulli（诺基亚），Teddie Stenvi（ST-Ericsson），Neil
    Trevett（Nvidia） Per Wennersten（爱立信），Per-Erik Brodin（爱立信），Shiki Okasaka（谷歌），Tom Olson（ARM），姚正荣（爱立信）以及Khronos
    WebGL工作组成员。
</p>
</body>
</html>